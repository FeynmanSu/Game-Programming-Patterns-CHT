<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />

<title>事件隊列 &middot; Decoupling Patterns &middot; 遊戲設計模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<!--
delete the font style for english.
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
-->
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="component.html">上一章</a></span>
  <span class="next"><a href="service-locator.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
<h1>事件隊列</h1>
<h1 class="book"><a href="/">遊戲設計模式</a><span class="section"><a href="decoupling-patterns.html">Decoupling Patterns</a></span></h1>
<h2><a href="#意圖" name="意圖">意圖</a></h2>
<p><em>解耦發出消息或事件的時間和處理它的時間。</em></p>
<h2><a href="#動機" name="動機">動機</a></h2>
<p><span name="message"></span></p>
<p>除非還獃在一兩個沒有互聯網接入的犄角旮旯，否則你很可能已經聽說過“事件序列”了。
如果沒有，也許“消息隊列”或“事件循環”或“消息泵”可以讓你想起些什麼。
為了喚醒你的記憶，讓我們瞭解幾個此模式的常見應用吧。</p>
<aside name="message">
<p>這章的大部分裡，我交替使用“事件”和“消息”。
在兩者的意義有區別時，我會表明的。</p>
</aside>
<h3><a href="#gui事件循環" name="gui事件循環">GUI事件循環</a></h3>
<p><span name="event-driven"></span></p>
<p>如果你曾做過任何用戶界面編程，你就會很熟悉<em>事件</em>。
每當用戶與你的程序交互——點擊按鈕，拉出菜單，或者按個鍵——操作系統就會生成一個事件。
它會將這個對象扔給你的應用程序，你的工作就是獲取它然後將其與有趣的行為相掛鉤。</p>
<aside name="event-driven">
<p>這個程序風格非常普遍，被認為是一種編程範式：<a href="http://en.wikipedia.org/wiki/Event-driven_programming"><em>事件驅動編程</em></a>。</p>
</aside>
<p>為了獲取這些事件，代碼底層是<em>事件循環</em>。它大體上是這樣的：</p>
<div class="codehilite"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Event</span> <span class="n">event</span> <span class="o">=</span> <span class="n">getNextEvent</span><span class="p">();</span>
  <span class="c1">// 處理事件……</span>
<span class="p">}</span>
</pre></div>


<p><span name="interrupt"></span></p>
<p>對<code>getNextEvent()</code>的調用將一堆未處理的用戶輸出傳到應用程序中。
你將它導向事件處理器，之後應用魔術般獲得了生命。
有趣的部分是應用在<em>它</em>想要的時候<em>獲取</em>事件。
操作系統在用戶操作時不是直接跳轉到你應用的某處代碼。</p>
<aside name="interrupt">
<p>相反，操作系統的<em>中斷</em>確實是直接跳轉的。
當中断發生時，操作系統中斷應用在做的事，強制它跳到中斷處理。
這種唐突的做法是中斷很難使用的原因。</p>
</aside>
<p>這就意味著當用戶輸入進來時，它需要到某處去，
這樣操作系統在設備驅動報告輸入和應用去調用<code>getNextEvent()</code>之間不會漏掉它。
這個“某處”是一個<em>隊列</em>。</p>
<p><img src="images/event-queue-loop.png" alt="一個事件隊列。操作系統入隊Shift鍵，下方向鍵，上方向鍵，以及點擊事件，getNextEvent()函數可以讓它們出隊。" /></p>
<p>當用戶輸入抵達時，操作系統將其添加到未處理事件的隊列中。
當你調用<code>getNextEvent()</code>時，它從隊列中獲取最舊的事件然後交給應用程序。</p>
<h3><a href="#中心事件匯流排" name="中心事件匯流排">中心事件匯流排</a></h3>
<p><span name="game-loop"></span></p>
<p>大多數遊戲不是像這樣事件驅動的，但是在遊戲中使用事件循環來支撐中樞系統是很常見的。
你通常聽到用“中心”“全局”“主體”描述它。
它通常被用於想要相互保持解耦的高層模組間通信。</p>
<aside name="game-loop">
<p>如果你想知道<em>為什麼</em>它們不是事件驅動的，看看<a href="game-loop.html" class="pattern">遊戲循環</a>一章。</p>
</aside>
<p><span name="tutorial"></span></p>
<p>假設遊戲有新手教程系統，在某些特定遊戲事件後顯示幫助框。
舉個例子，當玩家第一次擊敗了邪惡野獸，你想要一個顯示著“按X拿起戰利品！”的小氣泡。</p>
<aside name="tutorial">
<p>新手教程系統很難優雅地實現，大多數玩家很少使用遊戲內的幫助，所以這感覺上吃力不討好。
但對那些<em>使用</em>教程的玩家，這是無價之物。</p>
</aside>
<p>遊戲玩法和戰鬥代碼也許像上面一樣複雜。
你最不想做的就是檢查一堆教程的觸發器。
相反，你可以使用中心事件隊列。
任何遊戲系統都可以發事件給隊列，這樣戰鬥代碼可以在砍倒敵人時發出“敵人死亡”事件。</p>
<p><span name="blackboard"></span></p>
<p>類似的，任何遊戲系統都能從隊列<em>接受</em>事件。
教程引擎在隊列中註冊自己，然後表明它想要收到“敵人死亡”事件。
用這種方式，敵人死了的消息從戰鬥系統傳到了教程引擎，而不需要這兩個系統直接知道對方的存在。</p>
<aside name="blackboard">
<p>實體可以發送和收到消息的模型很像AI界的<a href="http://en.wikipedia.org/wiki/Blackboard_system">blackboard systems</a>。</p>
</aside>
<p><img src="images/event-queue-central.png" alt="一個戰鬥代碼和教程代碼都可以讀寫的中心事件隊列。" /></p>
<p>我本想將這個作為這章其他部分的例子，但是我真不喜歡這樣巨大的全局系統。
事件隊列不需要在整個遊戲引擎中溝通。在一個類或者領域中溝通就足夠有用了。</p>
<h3><a href="#你說什麼？" name="你說什麼？">你說什麼？</a></h3>
<p>所以說點別的，讓我們給遊戲添加一些聲音。
人類是視覺動物，但是聽覺強烈影響到情感系統和空間感覺。
正確模擬的回聲可以讓漆黑的屏幕感覺上是巨大的洞穴，而適時的小提琴慢板可以讓心弦拉響同樣的旋律。</p>
<p><span name="singleton"></span></p>
<p>為了獲得優秀的音效表現，我們從最簡單的解決方法開始，看看結果如何。
添加一個“聲音引擎”，其中有使用標識符和音量就可以播放音樂的API：</p>
<aside name="singleton">
<p>我總是離<a href="singleton.html" class="gof-pattern">單例模式</a>遠遠的。
這是少數它可以使用的領域，因為機器通常只有一個聲源系統。
我使用更簡單的方法，直接將方法定為靜態。</p>
</aside>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Audio</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">volume</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<p>它負責加載合適的聲音資源，找到可靠的播放頻道，然後啟動它。
這章不是關於某個平台真實的音頻API，所以我會假設在其他某處魔術般實現了一個。
使用它，我們像這樣寫方法：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Audio</span><span class="o">::</span><span class="n">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">volume</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ResourceId</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">loadSound</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">findOpenChannel</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">startSound</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">volume</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>我們簽入以上代碼，創建一些聲音檔案，然後在代碼中加入一些對<code>playSound()</code>的調用。
舉個例子，在UI代碼中，我們在選擇菜單項變化時播放一點小音效：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Menu</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">onSelect</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Audio</span><span class="o">::</span><span class="n">playSound</span><span class="p">(</span><span class="n">SOUND_BLOOP</span><span class="p">,</span> <span class="n">VOL_MAX</span><span class="p">);</span>
    <span class="c1">// 其他代碼……</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>這樣做了之後，注意到有時候你改變菜單項目，整個屏幕就會凍住幾幀。
我們遇到了第一個問題：</p>
<ul>
<li><strong>問題一：API在音頻引擎完成對請求的處理前阻塞了調用者。</strong></li>
</ul>
<p>我們的<code>playSound()</code>方法是<em>同步</em>的——它在從播放器放出聲音前不會返回調用者。
如果聲音檔案要從光盤上加載，那就得花費一定時間。
與此同時，遊戲的其他部分被卡住了。</p>
<p>現在忽視這一點，我們繼續。
在AI代碼中，我們增加了一個調用，在敵人承受玩家傷害時發出痛苦的低號。
沒有什麼比在虛擬的生物身上施加痛苦更能溫暖玩家心靈的了。</p>
<p><span name="hatsworth"></span></p>
<p>這能行，但是有時玩家打出暴擊，他在同一幀可打到兩個敵人。
這讓遊戲同時要播放兩遍哀嚎。
如果你瞭解一些音頻的知識，那麼就知道要把兩個不同的聲音混合在一起，就要加和它們的波形。
當這兩個是<em>同一</em>波形時，它與<em>一個</em>聲音播放<em>兩倍響</em>是一樣的。那會很刺耳。</p>
<aside name="hatsworth">
<p>我在完成<a href="http://en.wikipedia.org/wiki/Henry_Hatsworth_in_the_Puzzling_Adventure">Henry Hatsworth in the Puzzling Adventure</a>遇到了同樣的問題。解決方法和這裡的很相似。</p>
</aside>
<p>在Boss戰中有個相關的問題，當有一堆小怪跑動製造傷害時。
硬件只能同時播放一定數量的音頻。當數量超過限度時，聲音就被忽視或者切斷了。</p>
<p>為了處理這些問題，我們需要獲得音頻調用的整個<em>集合</em>，用來整合和排序。
不幸的是，音頻API獨立處理每一個<code>playSound()</code>調用。
看起來這些請求是從針眼穿過一樣，一次只能有一個。</p>
<ul>
<li><strong>問題二：請求無法合併處理。</strong></li>
</ul>
<p>這個問題與下面的問題相比只是小煩惱。
現在，我們在很多不同的遊戲系統中散佈了<code>playSound()</code>調用。
但是遊戲引擎是在現代多核機器上運行的。
為了使用多核帶來的優勢，我們將系統分散在不同線程上——渲染在一個，AI在另一個，諸如此類。</p>
<p>由於我們的API是同步的，它在<em>調用者</em>的線程上運行。
當從不同的遊戲系統調用時，我們從多個線程同時使用API。
看看示例代碼，看到任何線程同步性嗎？我也沒看到。</p>
<p>當我們想要分配一個<em>單獨的</em>線程給音頻，這個問題就更加嚴重。
當其他線程都忙於互相跟隨和製造事物，它只是傻傻待在那裡。</p>
<ul>
<li><strong>問題三：請求在錯誤的線程上執行。</strong></li>
</ul>
<p>音頻引擎調用<code>playSound()</code>意味著，“放下任何東西，現在就播放聲音！”<em>立即</em> 就是問題。
遊戲系統在<em>它們</em>方便時調用<code>playSound()</code>，但是音頻引擎不一定能方便去處理這個請求。
為瞭解決這點，我們需要將<em>接受</em>請求和<em>處理</em>請求解耦。</p>
<h2><a href="#模式" name="模式">模式</a></h2>
<p><strong>事件隊列</strong>在隊列中按先入先出的順序存儲一系列<strong>通知或請求</strong>。
發送通知時，<strong>將請求放入隊列並返回</strong>。
處理請求的系統之後稍晚<strong>從隊列中獲取請求</strong>並處理。
這<strong>解耦了發送者和接收者</strong>，既<strong>靜態</strong>又<strong>及時</strong>。</p>
<h2><a href="#何時使用" name="何時使用">何時使用</a></h2>
<p><span name="simple"></span></p>
<p>如果你只是想解耦<em>接收者</em>和發送者，像<a href="observer.html">觀察者模式</a>
和<a href="command.html">命令模式</a>都可以用較小的複雜度進行處理。
在解耦某些需要<em>及時</em>處理的東西時使用隊列。</p>
<aside name="simple">
<p>我在之前的几乎每章都提到了，但這值得反復提。
複雜度會拖慢你，所以要將簡單視為珍貴的財寶。</p>
</aside>
<p>用推和拉來考慮。
有一塊代碼A需要另一塊代碼B去做些事情。
對A自然的處理方式是將請求<em>推</em>給B。</p>
<p>同時，對B自然的處理方式是在<em>B</em>方便時將請求<em>拉</em>入。
當一端有推模型另一端有拉模型，你需要在它們間放緩存。
這就是隊列比簡單的解耦模式多提供的部分。</p>
<p>隊列給了代碼對拉取的控制權——接收者可以延遲處理，合併或者忽視請求。
但隊列做這些事是通過將控制權從發送者那裡<em>拿走</em>完成的。
發送者能做的就是向隊列發送請求然後祈禱。
當發送者需要回覆時，隊列不是好選擇。</p>
<h2><a href="#記住" name="記住">記住</a></h2>
<p>不像這書中的其他模式，事件隊列很複雜，會對遊戲架構引起廣泛影響。
這就意味著你仔細考慮如何——或者要不要——使用它。</p>
<h3><a href="#中心事件隊列是一個全局變數" name="中心事件隊列是一個全局變數">中心事件隊列是一個全局變數</a></h3>
<p>這個模式的常用方法是一個大的交換站，遊戲中的每個部分都能將消息送過這裡。
這是很有用的基礎架構，但是<em>有用</em>並不代表<em>好用</em>。</p>
<p>可能要走一些彎路，但是我們中的大多數最終學到了全局變數是不好的。
當有一小片狀態，程序的每部分都能接觸到，會產生各種微妙的相關性。
這個模式將狀態封裝在協議中，但是它還是全局的，仍然有全局變數引發的全部危險。</p>
<h3><a href="#世界的狀態可以因你改變" name="世界的狀態可以因你改變">世界的狀態可以因你改變</a></h3>
<p>假設在虛擬的小怪結束它一生時，一些AI代碼將“實體死亡”事件發送到隊列中。
這個事件在隊列中等待了誰知有多少幀後才排到了前面，得以處理。</p>
<p>同時，經驗系統想要追蹤英雄的殺敵數，並對他的效率加以獎勵。
它接受每個“實體死亡”事件，然後決定英雄擊殺了何種怪物，以及擊殺的難易程度，最終計算出合適的獎勵。</p>
<p>這需要遊戲世界的多種不同狀態。
我們需要死亡的實體以獲取擊殺它的難度。
我們也許要看看英雄的周圍有什麼其他的障礙物或者怪物。
但是如果事件沒有及時處理，這些東西都會消失。
實體可能被清除，周圍的東西也有可能移開。</p>
<p>當你接到事件時，得小心，不能假設<em>現在的</em>狀態反映了<em>事件發生時</em>的世界。
這就意味著隊列中的事件比同步系統中的事件需要存儲更多數據。
在後者中，通知只需說“某事發生了”然後接收者可以找到細節。
使用隊列時，這些短暫的細節必須在事件發送時就被捕獲，以方便之後使用。</p>
<h3><a href="#會陷于反饋系統環路中" name="會陷于反饋系統環路中">會陷于反饋系統環路中</a></h3>
<p>任何事件系統和消息系統都得擔心環路：</p>
<ol>
<li>A發送了一個事件</li>
<li>B接收然後發送事件作為回應。</li>
<li>這個事件恰好是A關注的，所以它收到了。為了回應，它發送了一個事件。</li>
<li>回到2.</li>
</ol>
<p><span name="log"></span></p>
<p>當消息系統是<em>同步的</em>，你很快就能找到環路——它們造成了棧溢出並讓遊戲崩潰。
使用隊列，非同步地使用棧，即使虛假事件晃來晃去時，遊戲仍然可以繼續運行。
避免這個的通用方法就是避免在<em>處理</em>事件的代碼中<em>發送</em>事件。</p>
<aside name="log">
<p>在你的事件系統中加一個小小的漏洞日誌也是一個好主意。</p>
</aside>
<h2><a href="#示例代碼" name="示例代碼">示例代碼</a></h2>
<p>我們已經看到一些代碼了。它不完美，但是有基本的正確功能——公用的API和正確的底層音頻調用。
剩下需要做的就是修復它的問題。</p>
<p>第一個問題是我們的API是<em>阻塞的</em>。
當代碼播放聲音時，它不能做任何其他事情，直到<code>playSound()</code>加載完音頻然後真正地開始播放。</p>
<p>我們想要推遲這項工作，這樣 <code>playSound()</code> 可以很快的返回。
為了達到這一點，我們需要<em>具體化</em>播放聲音的請求。
我們需要一個小結構存儲發送請求時的細節，這樣我們晚些時候可以使用：</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">PlayMessage</span>
<span class="p">{</span>
  <span class="n">SoundId</span> <span class="n">id</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">volume</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>下面我們需要給<code>Audio</code>一些存儲空間來追蹤正在播放的聲音。
現在，你的算法專家也許會告訴你使用激動人心的資料結構，
比如<a href="http://en.wikipedia.org/wiki/Fibonacci_heap">Fibonacci heap</a>或者<a href="http://en.wikipedia.org/wiki/Skip_list">skip list</a>或者最起碼<em>鏈表</em>。
但是在實踐中，存儲一堆同類事物最好的辦法是使用一個平凡無奇的經典數組：</p>
<aside name="prof">
<p>算法研究者通過發表新奇資料結構的研究獲得收入。
他們不鼓勵使用基本的結構。</p>
</aside>
<ul>
<li>
<p>沒有動態分配。</p>
</li>
<li>
<p>沒有為記錄信息造成額外的開銷或者多餘的指針。</p>
</li>
</ul>
<p><span name="locality"></span></p>
<ul>
<li>對緩存友好的連續存儲空間。</li>
</ul>
<aside name="locality">
<p>更多“緩存友好”的內容，見<a href="data-locality.html" class="pattern">數據局部性</a>一章。</p>
</aside>
<p>所以讓我們開干吧：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Audio</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">numPending_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 其他代碼……</span>
<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_PENDING</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

  <span class="k">static</span> <span class="n">PlayMessage</span> <span class="n">pending_</span><span class="p">[</span><span class="n">MAX_PENDING</span><span class="p">];</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">numPending_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>我們可以將數組大小設置為最糟情況下的大小。
為了播放聲音，簡單的將新消息插到最後：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Audio</span><span class="o">::</span><span class="n">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">volume</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">numPending_</span> <span class="o">&lt;</span> <span class="n">MAX_PENDING</span><span class="p">);</span>

  <span class="n">pending_</span><span class="p">[</span><span class="n">numPending_</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
  <span class="n">pending_</span><span class="p">[</span><span class="n">numPending_</span><span class="p">].</span><span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">;</span>
  <span class="n">numPending_</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>這讓<code>playSound()</code>几乎是立即返回，當然我們仍得播放聲音。
那塊代碼在某處，即<code>update()</code>方法中：</p>
<p><span name="update"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Audio</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numPending_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">ResourceId</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">loadSound</span><span class="p">(</span><span class="n">pending_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">findOpenChannel</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
      <span class="n">startSound</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">pending_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">volume</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">numPending_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 其他代碼……</span>
<span class="p">};</span>
</pre></div>


<aside name="update">
<p>就像名字暗示的，這是<a href="update-method.html" class="pattern">更新方法</a>模式。</p>
</aside>
<p>現在我們需要從方便時候調用。
這個“方便”取決於你的遊戲。
它也許要從主<a href="game-loop.html" class="pattern">遊戲循環中</a>或者專注于音頻的線程中調用。</p>
<p>這可行，但是這假定了我們在對<code>update()</code>的單一調用中可以處理<em>每個</em>聲音請求。
如果你做了像在聲音資源加載後處理非同步請求的事情，這就沒法工作了。
<code>update()</code>一次處理一個請求，它需要有完成一個請求後從緩存中再拉取一個請求的能力。
換言之，我們需要一個真實的隊列。</p>
<h3><a href="#環狀緩存" name="環狀緩存">環狀緩存</a></h3>
<p>有很多種方式能實現隊列，但我最喜歡的是<em>環狀緩存</em>。
它保留了數組的所有優點，同時能讓我們不斷從隊列的前方移除事物。</p>
<p>現在，我知道你在想什麼。
如果我們從數組的前方移除東西，不是需要將所有剩下的部分都移動一次嗎？這不是很慢嗎？</p>
<p>這就是為什麼要學習鏈表——你可以從中移除一個節點，而無需移動東西。
好吧，其實你可以用數組實現一個隊列而無需移動東西。
我會展示給你看，但是首先預習一些術語：</p>
<ul>
<li>
<p>隊列的<strong>頭部</strong>是<em>讀取</em>請求的地方。頭部存儲最早發出的請求。</p>
</li>
<li>
<p><strong>尾部</strong> 是另一端。它是數組中下個<em>寫入</em>請求的地方。注意它指向隊列終點的下一個。你可以將其理解為一個半開半閉區間，如果這有幫助的話。</p>
</li>
</ul>
<p>由於 <code>playSound()</code> 向數組的末尾添加了新的請求，頭部開始指向元素0而尾部向右增長。</p>
<p><img src="images/event-queue-queue.png" alt="一數組事件。頭部指向第一個元素，尾部向右增長。" /></p>
<p>讓我們開始編碼。首先，我們顯式定義這兩個標記在類中的意義：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Audio</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tail_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 方法……</span>
<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">head_</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">tail_</span><span class="p">;</span>

  <span class="c1">// 數組……</span>
<span class="p">};</span>
</pre></div>


<p>在 <code>playSound()</code> 的實現中，<code>numPending_</code>被<code>tail_</code>取代，但是其他都是一樣的：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Audio</span><span class="o">::</span><span class="n">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">volume</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">tail_</span> <span class="o">&lt;</span> <span class="n">MAX_PENDING</span><span class="p">);</span>

  <span class="c1">// Add to the end of the list.</span>
  <span class="n">pending_</span><span class="p">[</span><span class="n">tail_</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
  <span class="n">pending_</span><span class="p">[</span><span class="n">tail_</span><span class="p">].</span><span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">;</span>
  <span class="n">tail_</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>更有趣的變化在<code>update()</code>中：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Audio</span><span class="o">::</span><span class="n">update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// 如果這裡沒有待處理的請求</span>
  <span class="c1">// 那就什麼也不做。</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">head_</span> <span class="o">==</span> <span class="n">tail_</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="n">ResourceId</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">loadSound</span><span class="p">(</span><span class="n">pending_</span><span class="p">[</span><span class="n">head_</span><span class="p">].</span><span class="n">id</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">findOpenChannel</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">startSound</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">pending_</span><span class="p">[</span><span class="n">head_</span><span class="p">].</span><span class="n">volume</span><span class="p">);</span>

  <span class="n">head_</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>我們在頭部處理，然後通過將頭部指針向右移動來消除它。
我們定義頭尾之間沒有距離的隊列為<span name="empty">空隊列</span>。</p>
<aside name="empty">
<p>這就是為什麼我們讓尾部指向最後元素<em>之後</em>的那個位置。
這意味著頭尾相等則隊列為空。</p>
</aside>
<p><span name="party"></span></p>
<p>現在，我們獲得了一個隊列——我們可以向尾部添加元素，從頭部移除元素。
這裡有很明顯的問題。在我們讓隊列跑起來後，頭部和尾部繼續向右移動。
最終<code>tail_</code>碰到了數組的尾部，歡樂時光結束了。
接下來是這個方法的靈巧之處。</p>
<aside name="party">
<p>你想結束歡樂時光嗎？不，你不想。</p>
</aside>
<p><img src="images/event-queue-crawl.png" alt="像之前一樣的數組，但是現在頭部在向右移動，在左側留下空白格子。" /></p>
<p>注意當尾部移動時，<em>頭部</em> 也是如此。
這就意味著在數組<em>開始</em>部分的元素不再被使用了。
所以我們做的就是，當抵達末尾時，將尾部回折到數組的頭部。
這就是為什麼它被稱為<em>環狀</em>緩存，它表現的像是一個環狀的數組。</p>
<p><img src="images/event-queue-ring.png" alt="數組繞了一圈，現在頭部可以回到開始時指向的地方了。" /></p>
<p>這個的實現非常簡單。
當我們入隊一個事物時，只需要保證尾部在抵達結束的時候回折到數組的開頭：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Audio</span><span class="o">::</span><span class="n">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">volume</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">assert</span><span class="p">((</span><span class="n">tail_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_PENDING</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">);</span>

  <span class="c1">// 添加到列表的尾部</span>
  <span class="n">pending_</span><span class="p">[</span><span class="n">tail_</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
  <span class="n">pending_</span><span class="p">[</span><span class="n">tail_</span><span class="p">].</span><span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">;</span>
  <span class="n">tail_</span> <span class="o">=</span> <span class="p">(</span><span class="n">tail_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_PENDING</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>替代<code>tail++</code>，將增量設為數組長度的模，這樣可將尾部回折回來。
另一個改變是斷言。我們得保證隊列不會溢出。
只要這裡有少於<code>MAX_PENDING</code>的請求在隊列中，在頭部和尾部之間就有沒有使用的間隔。
如果隊列滿了，那就不會有了，就像古怪的銜尾蛇一樣，尾部會遇到頭部然後覆蓋它。
斷言保證了這不會發生。</p>
<p>在<code>update()</code>中，頭部也回折了：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Audio</span><span class="o">::</span><span class="n">update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// 如果沒有待處理的請求，就啥也不做</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">head_</span> <span class="o">==</span> <span class="n">tail_</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="n">ResourceId</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">loadSound</span><span class="p">(</span><span class="n">pending_</span><span class="p">[</span><span class="n">head_</span><span class="p">].</span><span class="n">id</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">findOpenChannel</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">startSound</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">pending_</span><span class="p">[</span><span class="n">head_</span><span class="p">].</span><span class="n">volume</span><span class="p">);</span>

  <span class="n">head_</span> <span class="o">=</span> <span class="p">(</span><span class="n">head_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_PENDING</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><span name="capacity"></span></p>
<p>這樣就好——沒有動態分配，沒有數據拷貝，緩存友好的簡單數組實現的隊列完成了。</p>
<aside name="capacity">
<p>如果最大容量影響了你，你可以使用增長的數組。
當隊列滿了後，分配一塊當前數組兩倍大的數組（或者更多倍），然後將對象拷進去。</p>
<p>哪怕你在隊列增長時拷貝，入隊仍然有常數級的<em>攤銷</em>複雜度。</p>
</aside>
<h3><a href="#合併請求" name="合併請求">合併請求</a></h3>
<p>現在有隊列了，我們可以轉向其他問題了。
首先來解決多重請求播放同一音頻，最終導致音量過大的問題。
由於我們知道哪些請求在等待處理，需要做的所有事就是將請求和早先等待處理的請求合併：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Audio</span><span class="o">::</span><span class="n">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">volume</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 遍歷待處理的請求</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">;</span>
       <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_PENDING</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pending_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// 使用較大的音量</span>
      <span class="n">pending_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">volume</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">pending_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">volume</span><span class="p">);</span>

      <span class="c1">// 無需入隊</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 之前的代碼……</span>
<span class="p">}</span>
</pre></div>


<p>當有兩個請求播放同一音頻時，我們將它們合併成只保留聲音最大的請求。
這一“合併”非常簡陋，但是我們可以用同樣的方法做很多有趣的合併。</p>
<p>注意在請求<em>入隊</em>時合併，而不是<em>處理</em>時。
在隊列中處理更加容易，因為不需要在最終會被合併的多餘請求上浪費時間。
這也更加容易被實現。</p>
<p><span name="slow"></span></p>
<p>但是，這確實將處理的職責放在了調用者肩上。
對<code>playSound()</code>的調用返回前會遍歷整個隊列。
如果隊列很長，那麼會很慢。
在<code>update()</code>中合併也許更加合理。</p>
<aside name="slow">
<p>避免<em>O(n)</em> 的隊列掃瞄代價的另一種方式是使用不同的資料結構。
如果我們將<code>SoundId</code>作為哈希表的鍵，那麼我們就可以在常量時間內檢查重複。</p>
</aside>
<p>這裡有些要記住的要點。
我們能夠合併的“同步”請求窗口只有隊列長度那麼大。
如果我們快速處理請求，隊列長度就會保持較短，我們就有更少的機會合併東西。
同樣的，如果處理慢了，隊列滿了，我們能找到更多的東西合併。</p>
<p>這個模式隔離了請求者和何時請求被處理，但如果你將整個隊列交互視為與數組結構交互，
那麼發出請求和處理它之間的延遲會顯式的影響行為。
確認這麼做之前保證這不會造成問題。</p>
<h3><a href="#分離線程" name="分離線程">分離線程</a></h3>
<p>最終，最險惡的問題。
使用同步的音頻API，調用<code>playSound()</code>的線程就是處理請求的線程。
這通常不是我們想要的。</p>
<p><span name="multicore"></span></p>
<p>在今日的多核硬件上，你需要不止一個線程來最大程度使用晶片。
有無數的編程範式在線程間分散代碼，但是最通用的策略是將每個獨立的領域分散到一個線程——音頻，渲染，AI等等。</p>
<aside name="multicore">
<p>單線程代碼同時只在一個核心上運行。
如果你不使用線程，哪怕做了流行的非同步風格編程，能做的極限就是讓一個核心繁忙，那也只發揮CPU能力的一小部分。</p>
<p>伺服器程序員將他們的程序分割成多個獨立<em>進程</em>作為彌補。
這讓系統在不同的核上同時運行它們。
遊戲几乎總是單進程的，所以增加線程真的有用。</p>
</aside>
<p>我們很容易就能做到這一點是因為三個關鍵點：</p>
<ol>
<li>請求音頻的代碼與播放音頻的代碼解耦。</li>
<li>有隊列在兩者之間整理它們。</li>
<li>隊列與程序其他部分是隔離的。</li>
</ol>
<p>剩下要做的事情就是寫修改隊列的方法——<code>playSound()</code>和<code>update()</code>——使之線程安全。
通常，我會寫一寫具體代碼完成之，但是由於這是一本關於架構的書，我不想著眼于一些特定的API或者鎖機制。</p>
<p>從高層看來，我們只需保證隊列不是同時被修改的。
由於<code>playSound()</code>只做了一點點事情——基本上就是聲明欄位。——不會阻塞線程太長時間。
在<code>update()</code>中，我們等待條件變數之類的東西，直到有請求需要處理時才會消耗CPU循環。</p>
<h2><a href="#設計決策" name="設計決策">設計決策</a></h2>
<p>很多遊戲使用事件隊列作為交流結構的關鍵部分，你可以花很多時間設計各種複雜的路徑和消息過濾器。
但是在構建洛杉磯電話交換機之類的東西之前，我推薦你從簡單開始。這裡是幾個需要在開始時思考的問題：</p>
<h3><a href="#隊列中存儲了什麼？" name="隊列中存儲了什麼？">隊列中存儲了什麼？</a></h3>
<p>到目前為止，我交替使用“事件”和“消息”，因為大多時候兩者的區別並不重要。
無論你在隊列中塞了什麼都可以獲得解耦和合併的能力，但是還是有幾個地方不同。</p>
<ul>
<li>
<p><strong>如果你存儲事件：</strong></p>
<p>“事件”或者“通知”描繪<em>已經</em>發生的事情，比如“怪物死了”。
你入隊它，這樣其他對象可以對這個事件作出<em>回應</em>，有點像非同步的<a href="observer.html" class="gof-pattern">觀察者</a>模式。</p>
<ul>
<li>
<p><em>很可能允許多個監聽者。</em>
由於隊列包含的是已經發生的事情，發送者可能不關心誰接受它。
從這個層面來說，事件發生在過去，早已被遺忘。</p>
</li>
<li>
<p><em>訪問隊列的模組更廣。</em>
事件隊列通常<em>廣播</em>事件到任何感興趣的部分。為了最大程度允許哪些部分能興趣，隊列一般是全局可見的。</p>
</li>
</ul>
</li>
<li>
<p><strong>如果你存儲消息：</strong></p>
<p><span name="command"></span></p>
<p>“消息”或“請求”描繪了<em>想要</em>發生<em>在未來</em>的事情，比如“播放聲音”。可以將其視為服務的非同步API。</p>
<aside name="command">

<p>另一個描述“請求”的詞是“命令”，就像在<a href="command.html" class="gof-pattern">命令模式</a>中那樣，隊列也可以在那裡使用。</p>
</aside>

<p><span name="locator"></span></p>
<ul>
<li>
<p><em>更可能只有一個監聽者。</em>
 在這個例子中，存儲的消息只請求<em>音頻API</em>播放聲音。如果引擎的隨便什麼部分都能從隊列中拿走消息，那可不好。</p>
<aside name="locator">

<p>我在這裡說“更可能”，因為只要像期望的<em>那樣</em>處理消息，消息入隊時可以不必擔心哪塊代碼處理它。
這樣的話，你在做的事情類似於<a href="service-locator.html" class="pattern">服務定位器</a>。</p>
</aside>

</li>
</ul>
</li>
</ul>
<h3><a href="#誰能從隊列中讀取？" name="誰能從隊列中讀取？">誰能從隊列中讀取？</a></h3>
<p>在例子中，隊列是密封的，只有<code>Audio</code>類可以從中讀取。
在用戶交互的事件系統中，你可以在核心內容中註冊監聽器。
有時可以聽到術語“單播”和“廣播”來描述它，兩者都很有用。</p>
<ul>
<li>
<p><strong>單播隊列：</strong></p>
<p>在隊列是類API的一部分時是，單播很自然的。
就像我們的音頻例子，從調用者的角度，它們只能看到可以調用的<code>playSound()</code>方法。</p>
<ul>
<li>
<p><em>隊列變成了讀取者的實現細節。</em> 發送者知道的所有事就是發條消息。</p>
</li>
<li>
<p><em>隊列更封裝。</em> 其他都一樣時，越多封裝越方便。</p>
</li>
<li>
<p><em>無須擔心監聽者之間的競爭。</em>
使用多個監聽者，你需要決定每個隊列中的事物<em>一對多</em>分給全部的監聽者（廣播）
還是<em>每個</em>隊列中的事物<em>一對一</em>分給單獨的監聽者（更加像工作隊列）。</p>
<p>在兩種情況下，監聽者最終要麼做了多餘的事情要麼在相互干擾，你得謹慎考慮想要的行為。
使用單一的監聽者，這種複雜性消失了。</p>
</li>
</ul>
</li>
<li>
<p><strong>廣播隊列：</strong></p>
<p>這是大多數“事件”系統工作的方法。如果你有十個監聽者，一個事件進來，所有監聽者都能看到這個事件。</p>
<ul>
<li>
<p>事件可能無人接收。<em>
前面那點的必然推論就是如果有</em>零個*監聽者，沒有誰能看到這個事件。
在大多數廣播系統中，如果處理事件時沒有監聽者，事件就消失了。</p>
</li>
<li>
<p><em>也許需要過濾事件。</em>
廣播隊列經常對程序的所有部分可見，最終你會獲得一系列監聽者。
很多事件乘以很多監聽者，你會獲取一大堆事件處理器。</p>
<p>為了削減大小，大多數廣播事件系統讓監聽者篩出其需要接受的事件。
比如，可能它們只想要接受滑鼠事件或者在某一UI區域內的事件。</p>
</li>
</ul>
</li>
<li>
<p><strong>工作隊列：</strong></p>
<p>類似廣播隊列，有多個監聽器。不同之處在於每個隊列中的東西只會投到監聽器<em>其中的一個</em>。
常應用於將工作打包給同時運行的線程池。</p>
<ul>
<li><em>你得規劃。</em>
由於一個事物只有一個監聽器，隊列邏輯需要指出最好的選項。
這也許像round robin算法或者亂序選擇一樣簡單，或者可以使用更加複雜的優先度系統。</li>
</ul>
</li>
</ul>
<h3><a href="#誰能寫入隊列？" name="誰能寫入隊列？">誰能寫入隊列？</a></h3>
<p><span name="configs"></span></p>
<p>這是前一個設計決策的另一面。
這個模式兼容所有可能的讀/寫設置：一對一，一對多，多對一，多對多。</p>
<aside name="configs">
<p>你有時聽到用“扇入”描述多對一的溝通系統，而用“扇出”描述一對多的溝通系統。</p>
</aside>
<ul>
<li>
<p><strong> 使用單個寫入器：</strong></p>
<p>這種風格和同步的<a href="observer.html" class="gof-pattern">觀察者</a>模式很像。
有特定對象收集所有可接受的事件。</p>
<ul>
<li>
<p><em>你隱式知道事件是從哪裡來的。</em>
由於這裡只有一個對象可向隊列添加事件，任何監聽器都可以安全的假設那就是發送者。</p>
</li>
<li>
<p><em>通常允許多個讀取者。</em>
你可以使用單發送者對單接收者的隊列，但是這樣溝通系統更像純粹的隊列資料結構。</p>
</li>
</ul>
</li>
<li>
<p><strong>使用多個寫入器：</strong></p>
<p>這是例子中音頻引擎工作的方式。
由於<code>playSound()</code>是公開的方法，代碼庫的任何部分都能給隊列添加請求。“全局”或“中心”事件匯流排像這樣工作。</p>
<ul>
<li>
<p><em>得更小心環路。</em>
由於任何東西都有可能向隊列中添加東西，這更容易意外地在處理事件時添加事件。
如果你不小心，那可能會觸發反饋循環。</p>
</li>
<li>
<p><em>很可能需要在事件中添加對發送者的引用。</em>
 當監聽者接到事件時，它不知道是誰發送的，因為可能是任何人。
 如果它確實需要知道發送者，你得將發送者打包到事件對象中去，這樣監聽者才可以使用它。</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#對象在隊列中的生命周期如何？" name="對象在隊列中的生命周期如何？">對象在隊列中的生命周期如何？</a></h3>
<p>使用同步的通知，當所有的接收者完成了消息處理才會返回發送者。
這意味著消息本身可以安全的存在棧的局部變數中。
使用隊列，消息比讓它入隊的調用活得更久。</p>
<p>如果你是用有垃圾回收的語言，你無需過度擔心這個。
消息存到隊列中，會一直存到需要它的時候。
而在C或C++中，得由你來保證對象活的足夠長。</p>
<ul>
<li>
<p><strong>傳遞所有權：</strong></p>
<p>這是手動管理內存的傳統方法。當消息入隊時，隊列擁有了它，發送者不再擁有它。
當它被處理時，接收者獲取了所有權，負責銷毀他。</p>
<aside name="unique">

<p>在C++中，<code>unique_ptr&lt;T&gt;</code>給了你同樣的語義。</p>
</aside>

</li>
<li>
<p><strong>共享所有權：</strong></p>
<p>現在，甚至C++程序員都更適應垃圾回收了，分享所有權更加可接受。
這樣，消息只要有東西對其有引用就會存在，當被遺忘時自動釋放。</p>
<aside name="shared">

<p>同樣的，C++的風格是使用<code>shared_ptr&lt;T&gt;</code>。</p>
</aside>

</li>
<li>
<p><strong>隊列擁有它：</strong></p>
<p><span name="pool"></span></p>
<p>另一個選項是讓消息<em>永遠</em>存在於隊列中。
發送者不再自己分配消息的內存，它向內存請求一個“新的”消息。
隊列返回一個隊列中已經在內存的消息的引用，接收者引用隊列中相同的消息。</p>
<aside name="pool">

<p>換言之，隊列存儲的背後是一個<a href="object-pool.html" class="pattern">對象池</a>模式。</p>
</aside>

</li>
</ul>
<h2><a href="#參見" name="參見">參見</a></h2>
<ul>
<li>
<p>我在之前提到了幾次，很大程度上，
這個模式是廣為人知的<a href="observer.html" class="gof-pattern">觀察者</a>模式的非同步實現。</p>
</li>
<li>
<p>就像其他很多模式一樣，事件隊列有很多別名。
其中一個是“消息隊列”。這通常指代一個更高層次的實現。
事件隊列在應用<em>中</em>，消息隊列通常在應用<em>間</em>交流。</p>
<p>另一個術語是“發佈/提交”，有時被縮寫為“pubsub”。
就像“消息隊列”一樣，這通常指代更大的分散式系統，而不是現在關注的這個模式。</p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Finite-state_machine">確定狀態機</a>，很像GoF的<a href="state.html" class="gof-pattern">狀態模式</a>，需要一個輸入流。如果想要非同步響應，可以考慮隊列存儲它們。</p>
<p>當你有一對狀態機相互發送消息時，每個狀態機都有一個小小的未處理隊列（被稱為一個<em>信箱</em>），
然後你需要重新發明<a href="http://en.wikipedia.org/wiki/Actor_model">actor model</a>。</p>
</li>
<li>
<p><a href="http://golang.org/">Go</a>語言內建的“通道”類型本質上是事件隊列或消息隊列。</p>
</li>
</ul>
<nav>
  <span class="prev">&larr; <a href="component.html">上一章</a></span>
  <span class="next"><a href="service-locator.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
