<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />

<title>觀察者模式 &middot; Design Patterns Revisited &middot; 遊戲設計模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<!--
delete the font style for english.
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
-->
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="flyweight.html">上一章</a></span>
  <span class="next"><a href="prototype.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
<h1>觀察者模式</h1>
<h1 class="book"><a href="/">遊戲設計模式</a><span class="section"><a href="design-patterns-revisited.html">Design Patterns Revisited</a></span></h1>
<p>隨便打開電腦中的一個應用，很有可能它就使用了<span name="devised"><a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC架構</a></span>，
而究其根本，是因為觀察者模式。
觀察者模式應用廣泛，Java甚至將其放到了核心庫之中（<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Observer.html"><code>java.util.Observer</code></a>），而C#直接將其嵌入了<em>語法</em>（<a href="http://msdn.microsoft.com/en-us/library/8627sbea.aspx"><code>event</code></a>關鍵字）。</p>
<aside name="devised">
<p>就像軟件中的很多東西，MVC是Smalltalkers在七十年代創造的。
Lisp程序員也許會說其實是他們在六十年代發明的，但是他們懶得記下來。</p>
</aside>
<p>觀察者模式是應用最廣泛和最廣為人知的GoF模式，但是遊戲開發世界與世隔絕，
所以對你來說，它也許是全新的。
假設你與世隔絕，讓我給你舉個形象的例子。</p>
<p><span name="weasel"></span></p>
<h2><a href="#成就解鎖" name="成就解鎖">成就解鎖</a></h2>
<p>假設我們向遊戲中添加了成就系統。
它存儲了玩家可以完成的各種各樣的成就，比如“殺死1000隻猴子惡魔”，“從橋上掉下去”，或者“一命通關”。</p>
<aside name="weasel">
<p><img src="images/observer-weasel-wielder.png" width="240" alt="成就：一無所成">

我發誓畫的這個沒有第二個意思，笑。</p>
</aside>
<p><span name="physics"></span>
要實現這樣一個包含各種行為來解鎖成就的系統是很有技巧的。
如果我們不夠小心，成就系統會纏繞在代碼庫的每個黑暗角落。
當然，“從橋上掉落”和物理引擎相關，
但我們並不想看到的在處理撞擊代碼的線性代數時，
有個對<code>unlockFallOffBridge()</code>的調用是不？</p>
<aside name="physics">
<p>這只是隨口一說。
有自尊的物理程序員絕不會允許像<em>遊戲玩法</em>這樣的平凡之物玷污他們優美的算式。</p>
</aside>
<p>我們喜歡的是，照舊，讓關注遊戲一部分的所有代碼整合到一塊。
挑戰在於，成就在遊戲的不同層面被觸發。怎麼解耦成就系統和其他部分呢？</p>
<p>這就是觀察者模式出現的原因。
這讓代碼宣稱有趣的事情發生了，<em>而不必關心到底是誰接受了通知。</em></p>
<p>舉個例子，有物理代碼處理重力，追蹤哪些物體待在地表，哪些墜入深淵。
為了實現“橋上掉落”的徽章，我們可以直接把成就代碼放在那裡，但那就會一團糟。
相反，可以這樣做：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Physics</span><span class="o">::</span><span class="n">updateEntity</span><span class="p">(</span><span class="n">Entity</span><span class="o">&amp;</span> <span class="n">entity</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">wasOnSurface</span> <span class="o">=</span> <span class="n">entity</span><span class="p">.</span><span class="n">isOnSurface</span><span class="p">();</span>
  <span class="n">entity</span><span class="p">.</span><span class="n">accelerate</span><span class="p">(</span><span class="n">GRAVITY</span><span class="p">);</span>
  <span class="n">entity</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">wasOnSurface</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">entity</span><span class="p">.</span><span class="n">isOnSurface</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">notify</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">EVENT_START_FALL</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><span name="subtle"></span>它做的就是聲稱，“額，我不知道有誰感興趣，但是這個東西剛剛掉下去了。做你想做的事吧。”</p>
<aside name="subtle">
<p>物理引擎確實決定了要發送什麼通知，所以這並沒有完全解耦。但在架構這個領域，通常只能讓系統變得<em>更好</em>，而不是<em>完美</em>。</p>
</aside>
<p>成就系統註冊它自己為觀察者，這樣無論何時物理代碼發送通知，成就系統都能收到。
它可以檢查掉落的物體是不是我們的失足英雄，
他之前有沒有做過這種不愉快的與橋的經典力學遭遇。
如果滿足條件，就伴著禮花和炫光解鎖合適的成就，而這些都無需牽扯到物理代碼。</p>
<p><span name="tear"></span>
事實上，我們可以改變成就的集合或者刪除整個成就系統，而不必修改物理引擎。
它仍然會發送它的通知，哪怕實際沒有東西接收。</p>
<aside name="tear">
<p>當然，如果我們<em>永久</em>移除成就，沒有任何東西需要物理引擎的通知，
我們也同樣可以移除通知代碼。但是在遊戲的演進中，最好保持這裡的靈活性。</p>
</aside>
<h2><a href="#它如何運作" name="它如何運作">它如何運作</a></h2>
<p>如果你還不知道如何實現這個模式，你可能可以從之前的描述中猜到，但是為了減輕你的負擔，我還是過一遍代碼吧。</p>
<h3><a href="#觀察者" name="觀察者">觀察者</a></h3>
<p>我們從那個需要知道別的對象做了什麼事的類開始。
這些好打聽的對象用如下介面定義：</p>
<p><span name="signature"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Observer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Observer</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onNotify</span><span class="p">(</span><span class="k">const</span> <span class="n">Entity</span><span class="o">&amp;</span> <span class="n">entity</span><span class="p">,</span> <span class="n">Event</span> <span class="n">event</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<aside name="signature">
<p><code>onNotify()</code>的參數取決於你。這就是為什麼是觀察者<em>模式</em>，
而不是“可以粘貼到遊戲中的真實代碼”。
典型的參數是發送通知的對象和一個裝入其他細節的“數據”參數。</p>
<p>如果你用泛型或者模板編程，你可能會在這裡使用它們，但是根據你的特殊用況裁剪它們也很好。
這裡，我將其硬編碼為接受一個遊戲實體和一個描述發生了什麼的枚舉。</p>
</aside>
<p>任何實現了這個的具體類就成為了觀察者。
在我們的例子中，是成就系統，所以我們可以像這樣實現：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Achievements</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Observer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onNotify</span><span class="p">(</span><span class="k">const</span> <span class="n">Entity</span><span class="o">&amp;</span> <span class="n">entity</span><span class="p">,</span> <span class="n">Event</span> <span class="n">event</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="nl">EVENT_ENTITY_FELL</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">entity</span><span class="p">.</span><span class="n">isHero</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">heroIsOnBridge_</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">unlock</span><span class="p">(</span><span class="n">ACHIEVEMENT_FELL_OFF_BRIDGE</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>

      <span class="c1">// 處理其他事件，更新heroIsOnBridge_變數……</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">unlock</span><span class="p">(</span><span class="n">Achievement</span> <span class="n">achievement</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 如果還沒有解鎖，那就解鎖成就……</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">heroIsOnBridge_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<h3><a href="#被觀察者" name="被觀察者">被觀察者</a></h3>
<p>被觀察的對象擁有通知的方法函數，用GoF的說法，那些對象被稱為“主題”。
它有兩個任務。首先，它有一個列表，保存默默等它通知的觀察者：</p>
<p><span name="stl"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Subject</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">Observer</span><span class="o">*</span> <span class="n">observers_</span><span class="p">[</span><span class="n">MAX_OBSERVERS</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">numObservers_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<aside name="stl">
<p>在真實代碼中，你會使用動態大小的集合而不是一個定長數組。
在這裡，我使用這種最基礎的形式是為了那些不瞭解C++標準庫的人們。</p>
</aside>
<p>重點是被觀察者暴露了<em>公開的</em>API來修改這個列表：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Subject</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">addObserver</span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span> <span class="n">observer</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 添加到數組中……</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">removeObserver</span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span> <span class="n">observer</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 從數組中移除……</span>
  <span class="p">}</span>

  <span class="c1">// 其他代碼……</span>
<span class="p">};</span>
</pre></div>


<p>這就允許了外界代碼控制誰接收通知。
被觀察者與觀察者交流，但是不與它們<em>耦合</em>。
在我們的例子中，沒有一行物理代碼會提及成就。
但它仍然可以與成就系統交流。這就是這個模式的聰慧之處。</p>
<p>被觀察者有一<em>列表</em>觀察者而不是單個觀察者也是很重要的。
這保證了觀察者不會相互干擾。
舉個例子，假設音頻引擎也需要觀察墜落事件來播放合適的音樂。
如果客體只支持單個觀察者，當音頻引擎註冊時，就會<em>取消</em>成就系統的註冊。</p>
<p>這意味著這兩個系統需要相互交互——而且是用一種極其糟糕的方式，
第二個註冊時會使第一個的註冊失效。
支持一列表的觀察者保證了每個觀察者都是被獨立處理的。
就它們各自的視角來看，自己是這世界上唯一看著被觀察者的。</p>
<p>被觀察者的剩餘任務就是發送通知：</p>
<p><span name="concurrent"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Subject</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">notify</span><span class="p">(</span><span class="k">const</span> <span class="n">Entity</span><span class="o">&amp;</span> <span class="n">entity</span><span class="p">,</span> <span class="n">Event</span> <span class="n">event</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numObservers_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">observers_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">onNotify</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 其他代碼…………</span>
<span class="p">};</span>
</pre></div>


<aside name="concurrent">
<p>注意，代碼假設了觀察者不會在它們的<code>onNotify()</code>方法中修改觀察者列表。
更加可靠的實現方法會阻止或優雅地處理這樣的並發修改。</p>
</aside>
<h3><a href="#可被觀察的物理系統" name="可被觀察的物理系統">可被觀察的物理系統</a></h3>
<p><span name="event"></span>
現在，我們只需要給物理引擎和這些掛鉤，這樣它可以發送消息，
成就系統可以和引擎連線來接受消息。
我們按照傳統的<em>設計模式</em>方法實現，繼承</span><code>Subject</code>：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Physics</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Subject</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">updateEntity</span><span class="p">(</span><span class="n">Entity</span><span class="o">&amp;</span> <span class="n">entity</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<p>這讓我們將<code>notify()</code>實現為了<code>Subject</code>內的保護方法。
這樣派生的物理引擎類可以調用並發送通知，但是外部的代碼不行。
同時，<code>addObserver()</code>和<code>removeObserver()</code>是公開的，
所以任何可以接觸物理引擎的東西都可以觀察它。</p>
<aside name="event">
<p>在真實代碼中，我會避免使用這裡的繼承。
相反，我會讓<code>Physics</code> <em>有</em> 一個<code>Subject</code>的實例。
不再是觀察物理引擎本身，被觀察的會是獨立的“下落事件”對象。
觀察者可以用像這樣註冊它們自己：</p>
<div class="codehilite"><pre><span></span><span class="n">physics</span><span class="p">.</span><span class="n">entityFell</span><span class="p">()</span>
  <span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</pre></div>


<p>對我而言，這是“觀察者”系統與“事件”系統的不同之處。
使用前者，你觀察<em>做了有趣事情的事物</em>。
使用後者，你觀察的對象代表了<em>發生的有趣事情</em>。</p>
</aside>
<p>現在，當物理引擎做了些值得關注的東西，它調用<code>notify()</code>，就像之前的例子。
它遍歷了觀察者列表，通知所有觀察者。</p>
<p><img src="images/observer-list.png" alt="被觀察者包含一列表觀察者的指針。前兩個指向成就和音頻系統。" /></p>
<p>很簡單，對吧？只要一個類管理一列表指向介面實例的指針。
難以置信的是，如此直觀的東西是無數程序和應用框架交流的主心骨。</p>
<p>觀察者模式不是完美無缺的。當我問其他程序員怎麼看，他們提出了一些抱怨。
讓我們看看可以做些什麼來處理這些抱怨。</p>
<h2><a href="#太慢了" name="太慢了">太慢了</a></h2>
<p>我經常聽到這點，通常是從那些不知道模式具體細節的程序員那裡。
他們有一種假設，任何東西只要沾到了“設計模式”，那麼一定包含了一堆類，跳轉和浪費CPU循環其他行為。</p>
<p><span name="names"></span>
觀察者模式的名聲特別壞，一些壞名聲的事物與它如影隨形，
比如“事件”，“消息”，甚至“數據綁定”。
其中的一些系統<em>確實會</em>慢。（通常是故意的，出於好的意圖）。
他們使用隊列，或者為每個通知動態分配內存。</p>
<aside name="names">
<p>這就是為什麼我認為設計模式文檔化很重要。
當我們沒有統一的術語，我們就失去了簡潔明確表達的能力。
你說“觀察者”，我以為是“事件”，他以為是“消息”，
因為沒人花時間記下差異，也沒人閱讀。</p>
<p>而那就是在這本書中我要做的。
本書中也有一章關於事件和消息：<a href="event-queue.html" class="pattern">事件隊列</a>.</p>
</aside>
<p>現在你看到了模式是如何真正被實現的，
你知道事實並不如他們所想的這樣。
發送通知只需簡單地遍歷列表，調用一些虛方法。
是的，這比靜態調用慢<em>一點</em>，除非是性能攸關的代碼，否則這點消耗都是微不足道的。</p>
<p>我發現這個模式在代碼性能瓶頸以外的地方能有很好的應用，
那些你可以承擔動態分配消耗的地方。
除那以外，使用它几乎毫無限制。
我們不必為消息分配對象，也無需使用隊列。這裡只多了一個用在同步方法調用上的額外跳轉。</p>
<h3><a href="#太*快*？" name="太*快*？">太<em>快</em>？</a></h3>
<p>事實上，你得小心，觀察者模式<em>是</em>同步的。
被觀察者直接調用了觀察者，這意味著直到所有觀察者的通知方法返回後，
被觀察者才會繼續自己的工作。觀察者會阻塞被觀察者的運行。</p>
<p>這聽起來很瘋狂，但在實踐中，這可不是世界末日。
這只是值得注意的事情。
UI程序員——那些使用基於事件的編程的程序員已經這麼幹了很多年了——有句經典名言：“遠離UI線程”。</p>
<p>如果要對事件同步響應，你需要完成響應，儘可能快的返回，這樣UI就不會鎖死。
當你有耗時的操作要執行時，將這些操作推到另一個線程或工作隊列中去。</p>
<p>你需要小心地在觀察者中混合線程和鎖。
如果觀察者試圖獲得被觀察者擁有的鎖，遊戲就進入死鎖了。
在多線程引擎中，你最好使用<a href="event-queue.html" class="pattern">事件隊列</a>來做非同步通信。</p>
<h2><a href="#“它做了太多動態分配”" name="“它做了太多動態分配”">“它做了太多動態分配”</a></h2>
<p><span name="fragment"></span>
整個程序員社區——包括很多遊戲開發者——轉向了擁有垃圾回收機制的語言，
動態分配今昔非比。
但在像遊戲這樣性能攸關的軟件中，哪怕是在有垃圾回收機制的語言，內存分配也依然重要。
動態</span>分配需要時間，回收內存也需要時間，哪怕是自動運行的。</p>
<aside name="fragment">
<p>很多遊戲開發者不怎麼擔心分配,但很擔心<em>分頁</em>。
當遊戲需要不崩潰的連續運行多日來獲得發售資格，不斷增加的分頁堆會影響遊戲的發售。</p>
<p><a href="object-pool.html" class="pattern">對象池</a>模式一章介紹了避免這點的常用技術，以及更多其他細節。</p>
</aside>
<p>在上面的示例代碼中，我使用的是定長數組，因為我想儘可能保證簡單。
在真實的項目中中，觀察者列表隨著觀察者的添加和刪除而動態地增長和縮短。
這種內存的分配嚇壞了一些人。</p>
<p>當然，第一件需要注意的事情是隻在觀察者加入時分配內存。
<em>發送</em> 通知無需內存分配——只需一個方法調用。
如果你在遊戲一開始就加入觀察者而不亂動它們，分配的總量是很小的。</p>
<p>如果這仍然困擾你，我會介紹一種無需任何動態分配的方式來增加和刪除觀察者。</p>
<h3><a href="#鏈式觀察者" name="鏈式觀察者">鏈式觀察者</a></h3>
<p>我們現在看到的所有代碼中，<code>Subject</code>擁有一列指針指向觀察它的<code>Observer</code>。
<code>Observer</code>類本身沒有對這個列表的引用。
它是純粹的虛介面。優先使用介面，而不是有狀態的具體類，這大體上是一件好事。</p>
<p>但是如果我們<em>確實</em>願意在<code>Observer</code>中放一些狀態，
我們可以將觀察者的列表分佈到<em>觀察者自己</em>中來解決動態分配問題。
不是被觀察者保留一列表分散的指針，觀察者對象本身成為了鏈表中的一部分：</p>
<p><img src="images/observer-linked.png" alt="一個觀察者的列表。每個都有一個next_欄位指向下一個。被觀察者有一個head_欄位指向首個觀察者。" /></p>
<p>為了實現這一點，我們首先要擺脫<code>Subject</code>中的數組，然後用鏈表頭部的指針取而代之：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Subject</span>
<span class="p">{</span>
  <span class="n">Subject</span><span class="p">()</span>
  <span class="o">:</span> <span class="n">head_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="c1">// 方法……</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">Observer</span><span class="o">*</span> <span class="n">head_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>然後，我們在<code>Observer</code>中添加指向鏈表中下一觀察者的指針。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Observer</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Subject</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">Observer</span><span class="p">()</span>
  <span class="o">:</span> <span class="n">next_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="c1">// 其他代碼……</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">Observer</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>這裡我們也讓<code>Subject</code>成為了友類。
被觀察者擁有增刪觀察者的API，但是現在鏈表在<code>Observer</code>內部管理。
最簡單的實現辦法就是讓被觀察者類成為友類。</p>
<p>註冊一個新觀察者就是將其連到鏈表中。我們用更簡單的實現方法，將其插到開頭：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Subject</span><span class="o">::</span><span class="n">addObserver</span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span> <span class="n">observer</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">observer</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">head_</span> <span class="o">=</span> <span class="n">observer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>另一個選項是將其添加到鏈表的末尾。這麼做增加了一定的複雜性。
<code>Subject</code>要麼遍歷整個鏈表來找到尾部，要麼保留一個單獨<code>tail_</code>指針指向最後一個節點。</p>
<p>加在在列表的頭很簡單，但也有另一副作用。
當我們遍歷列表給每個觀察者發送一個通知，
最<em>新</em>註冊的觀察者最<em>先</em>接到通知。
所以如果以A，B，C的順序來註冊觀察者，它們會以C，B，A的順序接到通知。</p>
<p>理論上，這種還是那種方式沒什麼差別。
在好的觀察者設計中，觀察同一被觀察者的兩個觀察者互相之間不該有任何順序相關。
如果順序<em>確實</em>有影響，這意味著這兩個觀察者有一些微妙的耦合，最終會害了你。</p>
<p>讓我們完成刪除操作：</p>
<p><span name="remove"></span></p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Subject</span><span class="o">::</span><span class="n">removeObserver</span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span> <span class="n">observer</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">head_</span> <span class="o">==</span> <span class="n">observer</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">observer</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
    <span class="n">observer</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Observer</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">==</span> <span class="n">observer</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">observer</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
      <span class="n">observer</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<aside name="remove">
<p>如你所見，從鏈表移除一個節點通常需要處理一些醜陋的特殊情況，應對頭節點。
還可以使用指針的指針，實現一個更優雅的方案。</p>
<p>我在這裡沒有那麼做，是因為半數看到這個方案的人都迷糊了。
但這是一個很值得做的練習：它能幫助你深入思考指針。</p>
</aside>
<p>因為使用的是鏈表，所以我們得遍歷它才能找到要刪除的觀察者。
如果我們使用普通的數組，也得做相同的事。
如果我們使用<em>雙向</em>鏈表，每個觀察者都有指向前面和後面的指針，
就可以用常量時間移除觀察者。在實際項目中，我會這樣做。</p>
<p><span name="chain"></span>剩下的事情只有發送通知了，這和遍歷列表同樣簡單；</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Subject</span><span class="o">::</span><span class="n">notify</span><span class="p">(</span><span class="k">const</span> <span class="n">Entity</span><span class="o">&amp;</span> <span class="n">entity</span><span class="p">,</span> <span class="n">Event</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Observer</span><span class="o">*</span> <span class="n">observer</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">observer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">observer</span><span class="o">-&gt;</span><span class="n">onNotify</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
    <span class="n">observer</span> <span class="o">=</span> <span class="n">observer</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<aside name="chain">
<p>這裡，我們遍歷了整個鏈表，通知了其中每一個觀察者。
這保證了所有的觀察者相互獨立並有同樣的優先順序。</p>
<p>我們可以這樣實現，當觀察者接到通知，它返回了一個標識，表明被觀察者是否應該繼續遍歷列表。
如果這樣做，你就接近了<a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern" class="gof-pattern">職責鏈</a>模式。</p>
</aside>
<p>不差嘛，對吧？被觀察者現在想有多少觀察者就有多少觀察者，無需動態內存。
註冊和取消註冊就像使用簡單數組一樣快。
但是，我們犧牲了一些小小的功能特性。</p>
<p>由於我們使用觀察者對象作為鏈表節點，這暗示它只能存在於一個觀察者鏈表中。
換言之，一個觀察者一次只能觀察一個被觀察者。
在傳統的實現中，每個被觀察者有獨立的列表，一個觀察者同時可以存在於多個列表中。</p>
<p>你也許可以接受這一限制。
通常是一個<em>被觀察者</em>有多個<em>觀察者</em>，反過來就很少見了。
如果這<em>真是</em>一個問題，這裡還有一種不必使用動態分配的解決方案。
詳細介紹的話，這章就太長了，但我會大致描述一下，其餘的你可以自行填補……</p>
<h3><a href="#鏈表節點池" name="鏈表節點池">鏈表節點池</a></h3>
<p><span name="intrusive"></span>
就像之前，每個被觀察者有一鏈表的觀察者。
但是，這些鏈表節點不是觀察者本身。
相反，它們是分散的小“鏈表節點”對象，
包含了指向觀察者的指針和指向鏈表下一節點的指針。</p>
<p><img src="images/observer-nodes.png" alt="一鏈表的節點。每個節點都有一個observer_欄位指向觀察者，一個next_欄位指向列表中的下一個節點。被觀察者的head_欄位指向第一個節點。" /></p>
<p>由於多個節點可以指向同一觀察者，這就意味著觀察者可以同時在超過多個被觀察者的列表中。
我們可以同時觀察多個對象了。</p>
<aside name="intrusive">
<p>鏈表有兩種風格。學校教授的那種，節點對象包含數據。
在我們之前的觀察者鏈表的例子中，是另一種：
<em>數據</em>（這個例子中是觀察者）包含了<em>節點</em>（<code>next_</code>指針）。</p>
<p>後者的風格被稱為“侵入式”鏈表，因為在對象內部使用鏈表侵入了對象本身的定義。
侵入式鏈表靈活性更小，但如我們所見，也更有效率。
在Linux核心這樣的地方這種風格很流行。</p>
</aside>
<p>避免動態分配的方法很簡單：由於這些節點都是同樣大小和類型，
可以預先在<a href="object-pool.html" class="pattern">對象池</a>中分配它們。
這樣你只需處理固定大小的列表節點，可以隨你所需使用和重用，
而無需牽扯到真正的內存分配器。</p>
<h2><a href="#剩餘的問題" name="剩餘的問題">剩餘的問題</a></h2>
<p>我認為三個該模式將人們嚇阻的主要問題已經被搞定了。
它簡單，快速，對內存管理友好。
但是這意味著你總該使用觀察者嗎？</p>
<p>現在，這是另一個的問題。
就像所有的設計模式，觀察者模式不是萬能藥。
哪怕可以正確高效的實現，它也不一定是好的解決方案。
設計模式有壞名聲的原因之一就是人們將好模式用在錯問題上，得到了糟糕的結果。</p>
<p>還有兩個挑戰，一個是關於技術，另一個更偏向是可維護性。
我們先處理關於技術的挑戰，因為關於技術的問題總是更容易處理。</p>
<h3><a href="#銷毀被觀察者和觀察者" name="銷毀被觀察者和觀察者">銷毀被觀察者和觀察者</a></h3>
<p><span name="destruct"></span>
我們看到的樣例代碼健壯可用，但有一個嚴重的副作用：
當刪除一個被觀察者或觀察者時會發生什麼？
如果你不小心的在某些觀察者上面調用了<code>delete</code>，被觀察者也許仍然持有指向它的指針。
那是一個指向一片已釋放區域的懸掛指針。
當被觀察者試圖發送一個通知，額……就說發生的事情會出乎你的意料之外吧。</p>
<aside name="destruct">
<p>不是譴責，但我注意到<em>設計模式</em>完全沒提這個問題。</p>
</aside>
<p>刪除被觀察者更容易些，因為在大多數實現中，觀察者沒有對它的引用。
但是即使這樣，將被觀察者所占的位元組直接回收也許會造成一些問題。
這些觀察者也許仍然期待在以後收到通知，而這是不可能的了。
它們沒法繼續觀察了，真的，它們只是認為它們可以。</p>
<p>你可以用好幾種方式處理這點。
最簡單的就是像我做的那樣，以後一腳踩空。
在被刪除時取消註冊是觀察者的職責。
多數情況下，觀察者<em>確實</em>知道它在觀察哪個被觀察者，
所以通常需要做的只是給它的析構器<span name="destructor">添加</span>一個<code>removeObserver()</code>。</p>
<aside name="destructor">
<p>通常在這種情況下，難點不在如何做，而在<em>記得</em>做。</p>
</aside>
<p><span name="mourn"></span>
如果在刪除被觀察者時，你不想讓觀察者處理問題，這也很好解決。
只需要讓被觀察者在它被刪除前發送一個最終的“死亡通知”。
這樣，任何觀察者都可以接收到，然後做些合適的行為</span>。</p>
<aside name="mourn">
<p>默哀，獻花，輓歌……</p>
</aside>
<p>人——哪怕是那些花費在大量時間在機器前，擁有讓我們黯然失色才能的人——也是絕對地不可靠。
這就是為什麼我們發明了電腦：它們不像我們那樣經常犯錯誤。</p>
<p>更安全的方案是在每個被觀察者銷毀時，讓觀察者自動取消註冊。
如果你在觀察者基類中實現了這個邏輯，每個人不必記住就可以使用它。
這確實增加了一定的複雜度。
這意味著每個<em>觀察者</em>都需要有它在觀察的<em>被觀察者</em>的列表。
最終維護一個雙向指針。</p>
<h3><a href="#別擔心，我有垃圾回收器" name="別擔心，我有垃圾回收器">別擔心，我有垃圾回收器</a></h3>
<p>你們那些裝備有垃圾回收系統的孩子現在一定很洋洋自得。
覺得你不必擔心這個，因為你從來不必顯式刪除任何東西？再仔細想想！</p>
<p>想象一下：你有UI顯示玩家角色情況的狀態，比如健康和道具。
當玩家在屏幕上時，你為其初始化了一個對象。
當UI退出時，你直接忘掉這個對象，交給GC清理。</p>
<p>每當角色臉上（或者其他什麼地方）挨了一拳，就發送一個通知。
UI觀察到了，然後更新健康槽。很好。
當玩家離開場景，但你沒有取消觀察者的註冊，會發生什麼？</p>
<p>UI界面不再可見，但也不會進入垃圾回收系統，因為角色的觀察者列表還保存著對它的引用。
每一次場景加載後，我們給那個不斷增長的觀察者列表添加一個新實例。</p>
<p>玩家玩遊戲時，來回跑動，打架，角色的通知發送給<em>所有</em>的界面。
它們不在屏幕上，但它們接受通知，這樣就浪費CPU循環在不可見的UI元素上了。
如果它們會播放聲音之類的，這樣的錯誤就會被人察覺。</p>
<p><span name="lapsed"></span>
這在通知系統中非常常見，甚至專門有個名字：<em>失效監聽者問題</em>。
由於被觀察者保留了對觀察者的引用，最終有UI界面對象僵死在內存中。
這裡的教訓是要及時刪除觀察者。</p>
<aside name="lapsed">
<p>它甚至有專門的<a href="http://en.wikipedia.org/wiki/Lapsed_listener_problem">維基條目</a>。</p>
</aside>
<h3><a href="#然後呢？" name="然後呢？">然後呢？</a></h3>
<p>觀察者的另一個深層次問題是它意圖直接導致的。
我們使用它是因為它幫助我們放鬆了兩塊代碼之間的耦合。
它讓觀察者與沒有靜態綁定的觀察者間接交流。</p>
<p>當你要理解被觀察者的行為時，這很有價值，任何不相關的事情都是在分散注意力。
如果你在處理物理引擎，你根本不想要編輯器——或者你的大腦——被一堆成就系統的東西而搞糊塗。</p>
<p>另一方面，如果你的程序沒能運行，漏洞散佈在多個觀察者之間，理清信息流變得更加困難。
顯式耦合中更易於查看哪一個方法被調用了。
這是因為耦合是靜態的，IDE分析它輕而易舉。</p>
<p>但是如果耦合發生在觀察者列表中，想要知道哪個觀察者被通知到了，唯一的辦法是看看哪個觀察者在列表中，而且<em>處于運行中</em>。
不再是理清程序的<em>靜態</em>交流結構，你得理清它的<em>命令式，動態</em>行為。</p>
<p>如何處理這個的指導原則很簡單。
如果為了理解程序的一部分，兩個交流的模組<em>都</em>需要考慮，
那就不要使用觀察者模式，使用其他更加顯式的東西。</p>
<p>當你在某些大型程序上用黑魔法時，你會感覺這樣處理很笨拙。
我們有很多術語用來描述，比如“關注點分離”，“一致性和內聚性”和“模組化”，
總歸就是“這些東西待在一起，而不是與那些東西待在一起。”</p>
<p>觀察者模式是一個讓這些不相關的代碼塊互相交流，而不必打包成更大塊的好方法。
這在專注于一個特性或層面的單一代碼塊<em>內</em>不會太有用。</p>
<p>這就是為什麼它能很好地適應我們的例子：
成就和物理是几乎完全不相干的領域，通常被不同人實現。
我們想要它們之間的交流最小化，
這樣無論在哪一個上工作都不需要另一個的太多信息。</p>
<h2><a href="#今日觀察者" name="今日觀察者">今日觀察者</a></h2>
<p><span name="90s"></span>
<em>設計模式</em>源於1994。
那時候，面向對象語言<em>正是</em> 熱門的編程範式。
每個程序員都想要“30天學會面向對象編程”，
中層管理員根據程序員創建類的數量為他們支付工資。
工程師通過繼承層次的深度評價代碼質量。</p>
<aside name="90s">
<p>同一年，Ace of Base的暢銷單曲發行了<em>三首</em>而不是一首，這也許能讓你瞭解一些我們那時的品味和洞察力。</p>
</aside>
<p>觀察者模式在那個時代中很流行，所以構建它需要很多類就不奇怪了。
但是現代的主流程序員更加適應函數式語言。
實現一整套介面只是為了接受一個通知不再符合今日的美學了。</p>
<p><span name="different"></span></p>
<p>它看上去是又沉重又死板。它<em>確實</em>又沉重又死板。
舉個例子，在觀察者類中，你不能為不同的被觀察者調用不同通知方法。</p>
<aside name="different">
<p>這就是為什麼被觀察者經常將自身傳給觀察者。
觀察者只有單一的<code>onNotify()</code>方法，
如果它觀察多個被觀察者，它需要知道哪個被觀察者在調用它的方法。</p>
</aside>
<p>現代的解決辦法是讓“觀察者”只是對方法或者函數的引用。
在函數作為第一公民的語言中，特別是那些有閉包的，
這種實現觀察者的方式更為普遍。</p>
<p><span name="closures"></span></p>
<aside name="closures">
<p>今日，几乎<em>每種</em>語言都有閉包。C++克服了在沒有垃圾回收的語言中構建閉包的挑戰，
甚至是Java都在JDK8中引入了閉包。</p>
</aside>
<p>舉個例子，C#有“事件”嵌在語言中。
通過這樣，觀察者是一個“委託”，
（“委託”是方法的引用在C#中的術語）。
在JavaScript事件系統中，觀察者<em>可以</em>是支持了特定<code>EventListener</code>協議的類，
但是它們也可以是函數。
後者是人們常用的方式。</p>
<p><span name="function"></span>
如果設計今日的觀察者模式，我會讓它基于函數而不是基于類。
哪怕是在C++中，我傾向于讓你註冊一個成員函數指針作為觀察者，而不是<code>Observer</code>介面的實例。</p>
<aside name="function">
<p><a href="http://molecularmusings.wordpress.com/2011/09/19/generic-type-safe-delegates-and-events-in-c/">這裡</a>的一篇有趣博文以某種方式在C++上實現了這一點。</p>
</aside>
<h2><a href="#明日觀察者" name="明日觀察者">明日觀察者</a></h2>
<p>事件系統和其他類似觀察者的模式如今遍地都是。
它們都是成熟的方案。
但是如果你用它們寫一個稍微大一些的應用，你會發現一件事情。
在觀察者中很多代碼最後都長得一樣。通常是這樣：</p>
<ol>
<li>獲知有狀態改變了。</li>
<li>下命令改變一些UI來反映新的狀態。</li>
</ol>
<p>就是這樣，“哦，英雄的健康現在是7了？讓我們把血條的寬度設為70像素。
過上一段時間，這會變得很沉悶。
計算機科學學術界和軟件工程師已經用了<em>很長</em>時間嘗試結束這種狀況了。
這些方式被賦予了不同的名字：“數據流編程”，“函數反射編程”等等。</p>
<p>即使有所突破，一般也侷限在特定的領域中，比如音頻處理或晶片設計，我們還沒有找到萬能鑰匙。
與此同時，一個更腳踏實地的方式開始獲得成效。那就是現在的很多應用框架使用的“數據綁定”。</p>
<p>不像激進的方式，數據綁定不再指望完全終結命令式代碼，
也不嘗試基于巨大的聲明式數據圖表架構整個應用。
它做的只是自動改變UI元素或計算某些數值來反映一些值的變化。</p>
<p>就像其他聲明式系統，數據綁定也許太慢，嵌入遊戲引擎的核心也太複雜。
但是如果說它不會侵入遊戲不那麼性能攸關的部分，比如UI，那我會很驚訝。</p>
<p>與此同時，經典觀察者模式仍然在那裡等著我們。
是的，它不像其他的新熱門技術一樣在名字中填滿了“函數”“反射”，
但是它超簡單而且能正常工作。對我而言，這通常是解決方案最重要的條件。</p>
<nav>
  <span class="prev">&larr; <a href="flyweight.html">上一章</a></span>
  <span class="next"><a href="prototype.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
