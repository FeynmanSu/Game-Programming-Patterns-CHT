<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />

<title>單例模式 &middot; Design Patterns Revisited &middot; 遊戲設計模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<!--
delete the font style for english.
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
-->
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="prototype.html">上一章</a></span>
  <span class="next"><a href="state.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
<h1>單例模式</h1>
<h1 class="book"><a href="/">遊戲設計模式</a><span class="section"><a href="design-patterns-revisited.html">Design Patterns Revisited</a></span></h1>
<p>這個章節不同尋常。
其他章節展示如何使用某個個設計模式。
這個章節展示如何<em>避免</em>使用某個設計模式。</p>
<p><span name="instance"></span>
儘管它的意圖是好的，GoF描述的<a class="gof-pattern" href="http://c2.com/cgi/wiki?SingletonPattern">單例模式</a>通常弊大於利。
他們強調應該謹慎使用這個模式，但在遊戲業界的口口相傳中，這一提示經常被無視了。</p>
<p>就像其他模式一樣，在不合適的地方使用單例模式就好像用夾板處理子彈傷口。
由於它被濫用得太嚴重了，這章的大部分都在講如何<em>迴避</em>單例模式，
但首先，讓我們看看模式本身。</p>
<aside name="instance">
<p>當業界從C語言遷移到面向對象的語言，他們遇到的首個問題是“如何訪問實例？”
他們知道有要調用的方法，但是找不到實例提供這個方法。
單例（換言之，全局化）是一條簡單的解決方案。</p>
</aside>
<h2><a href="#單例模式" name="單例模式">單例模式</a></h2>
<p><em>設計模式</em> 像這樣描述單例模式：</p>
<blockquote>
<p>保證一個類只有一個實例，並且提供了訪問該實例的全局訪問點。</p>
</blockquote>
<p>我們從“並且”那裡將句子分為兩部分，分別進行考慮。</p>
<h3><a href="#保證一個類只有一個實例" name="保證一個類只有一個實例">保證一個類只有一個實例</a></h3>
<p>有時候，如果類存在多個實例就不能正確的運行。
通常發生在類與保存全局狀態的外部系統互動。</p>
<p>考慮封裝檔案系統的API類。
因為檔案操作需要一段時間完成，所以類使用非同步操作。
這就意味著可以同時運行多個操作，必須讓它們相互協調。
如果一個操作創建檔案，另一個操作刪除同一檔案，封裝器類需要同時考慮，保證它們沒有相互妨礙。</p>
<p>為了實現這點，對我們封裝器類的調用必須接觸之前的每個操作。
如果用戶可以自由的創建類的實例，這個實例就無法知道另一實例之前的操作。
而單例模式提供的構建類的方式，在編譯時保證類只有單一實例。</p>
<h3><a href="#提供了訪問該實例的全局訪問點" name="提供了訪問該實例的全局訪問點">提供了訪問該實例的全局訪問點</a></h3>
<p>遊戲中的不同系統都會使用檔案系統封裝類：日誌，內容加載，遊戲狀態保存，等等。
如果這些系統不能創建檔案系統封裝類的實例，它們如何訪問該實例呢？</p>
<p>單例為這點也提供瞭解決方案。
除了創建單一實例以外，它也提供了一種獲得它的全局方法。
使用這種範式，無論何處何人都可以訪問實例。
綜合起來，經典的實現方案如下：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">FileSystem</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 惰性初始化</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">instance_</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">instance_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileSystem</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance_</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">FileSystem</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">static</span> <span class="n">FileSystem</span><span class="o">*</span> <span class="n">instance_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>靜態的<code>instance_</code>成員保存了一個類的實例，
私有的構造器保證了它是<em>唯一</em>的。
公開的靜態方法<code>instance()</code>讓任何地方的代碼都能訪問實例。
在首次被請求時，它同樣負責惰性實例化該單例。</p>
<p>現代的實現方案看起來是這樣的：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">FileSystem</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">static</span> <span class="n">FileSystem</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileSystem</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">FileSystem</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>


<p><span name="thread"></span>
哪怕是在多線程情況下，C++11標準也保證了本地靜態變數只會初始化一次，
因此，假設你有一個現代C++編譯器，這段代碼是線程安全的，而前面的那個例子不是。</p>
<aside name="thread">
<p>當然，你單例類本身的線程安全是個不同的問題！這裡只保證了它的<em>初始化</em>沒問題。</p>
</aside>
<h2><a href="#為什麼我們使用它" name="為什麼我們使用它">為什麼我們使用它</a></h2>
<p>看起來已有成效。
檔案系統封裝類在任何需要的地方都可用，而無需笨重地到處傳遞。
類本身巧妙地保證了我們不會實例化多個實例而搞砸。它還具有很多其他的優良性質：</p>
<ul>
<li>
<p><strong>如果沒人用，就不必創建實例。</strong>
    節約內存和CPU循環總是好的。
    由於單例只在第一次被請求時實例化，如果遊戲永遠不請求，那麼它不會被實例化。</p>
</li>
<li>
<p><strong>它在運行時實例化。</strong>
    通常的替代方案是使用含有靜態成員變數的類。
    我喜歡簡單的解決方案，因此我儘可能使用靜態類而不是單例，但是靜態成員有個限制：自動初始化。
    編譯器在<code>main()</code>運行前初始化靜態變數。
    這就意味著不能使用在程序加載時才獲取的信息（舉個例子，從檔案加載的配置）。
    這也意味著它們的相互依賴是不可靠的——編譯器可不保證以什麼樣的順序初始化靜態變數。</p>
<p>惰性初始化解決了以上兩個問題。
單例會儘可能晚的初始化，所以那時它需要的所有信息都應該可用了。
只要沒有環狀依賴，一個單例在初始化它自己的時甚至可以引用另一個單例。</p>
</li>
<li>
<p><strong>可繼承單例。</strong>
    這是個很有用但通常被忽視的能力。
    假設我們需要跨平台的檔案系統封裝類。
    為了達到這一點，我們需要它變成檔案系統抽象出來的介面，而子類為每個平台實現介面。
    這是基類：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">FileSystem</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">FileSystem</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">char</span><span class="o">*</span> <span class="n">readFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span>  <span class="nf">writeFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">contents</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>然後為一堆平台定義子類：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PS3FileSystem</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FileSystem</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">char</span><span class="o">*</span> <span class="n">readFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 使用索尼的檔案讀寫API……</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">writeFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">contents</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 使用索尼的檔案讀寫API……</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">WiiFileSystem</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FileSystem</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">char</span><span class="o">*</span> <span class="n">readFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 使用任天堂的檔案讀寫API……</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">writeFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">contents</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 使用任天堂的檔案讀寫API……</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>下一步，我們把<code>FileSystem</code>變成單例：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">FileSystem</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">();</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">FileSystem</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">char</span><span class="o">*</span> <span class="n">readFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span>  <span class="nf">writeFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">contents</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="n">FileSystem</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>


<p>靈巧之處在於如何創建實例：</p>
<div class="codehilite"><pre><span></span><span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">FileSystem</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
<span class="p">{</span>
  <span class="cp">#if PLATFORM == PLAYSTATION3</span>
    <span class="k">static</span> <span class="n">FileSystem</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PS3FileSystem</span><span class="p">();</span>
  <span class="cp">#elif PLATFORM == WII</span>
    <span class="k">static</span> <span class="n">FileSystem</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WiiFileSystem</span><span class="p">();</span>
  <span class="cp">#endif</span>

  <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>通過一個簡單的編譯器轉換，我們把檔案系統包裝類綁定到合適的具體類型上。
整個代碼庫都可以使用<code>FileSystem::instance()</code>接觸到檔案系統，而無需和任何平台相關的代碼耦合。耦合發生在為特定平台寫的<code>FileSystem</code>類實現檔案中。</p>
</li>
</ul>
<p>大多數人解決問題到這個程度就已經夠了。
我們得到了一個檔案系統封裝類。
它工作可靠，它全局有效，只要請求就能獲取。
是時候提交代碼，開懷暢飲了。</p>
<h2><a href="#為什麼我們後悔使用它" name="為什麼我們後悔使用它">為什麼我們後悔使用它</a></h2>
<p>短期來看，單例模式是相對良性的。
就像其他設計決策一樣，我們需要從長期考慮。
這裡是一旦我們將一些不必要的單例寫進代碼，會給自己帶來的麻煩：</p>
<h3><a href="#它是一個全局變數" name="它是一個全局變數">它是一個全局變數</a></h3>
<p>當遊戲還是由幾個傢伙在車庫中完成時，榨乾硬件性能比象牙塔裡的軟件工程原則更重要。
C語言和彙編程序員前輩能毫無問題的使用全局變數和靜態變數，發佈好遊戲。
但隨著遊戲變得越來越大，越來越複雜，架構和管理開始變成瓶頸，
阻礙我們發佈遊戲的，除了硬件限制，還有<em>生產力</em>限制。</p>
<p>所以我們遷移到了像C++這樣的語言，
開始將一些從軟件工程師前輩那裡學到的智慧應用於實際。
其中一課是全局變數有害的諸多原因：</p>
<p><span name="pure"></span></p>
<ul>
<li>
<p><strong>理解代碼更加困難。</strong>
    假設我們在查找其他人所寫函數中的漏洞。
    如果函數沒有碰到任何全局狀態，腦子只需圍著函數轉，
    只需搞懂函數和傳給函數的變數。</p>
<aside name="pure">

<p>計算機科學家稱不接觸不修改全局狀態的函數為“純”函數。
純函數易於理解，易於編譯器優化，
易於完成優雅的任務，比如記住緩存的情況並繼續上次調用。</p>
<p>完全使用純函數是有難度的，但其好處足以引誘科學家創造像Haskell這樣<em>只</em>使用純函數的語言。</p>
</aside>

<p>現在考慮函數中間是個對<code>SomeClass::getSomeGlobalData()</code>的調用。為了查明發生了什麼，得追蹤整個代碼庫來看看什麼修改了全局變數。你真的不需要討厭全局變數，直到你在凌晨三點使用<code>grep</code>搜索數百萬行代碼，搞清楚哪一個錯誤的調用將一個靜態變數設為了錯誤的值。</p>
</li>
<li>
<p><strong>促進了耦合的發生。</strong>
    新加入團隊的程序員也許不熟悉你們完美，可維護，鬆散耦合的遊戲架構，
    但還是剛剛獲得了第一個任務：在岩石撞擊地面時播放聲音。
    你我都知道這不需要將物理和<em>音頻</em>代碼耦合，但是他只想著把任務完成。
    不幸的是，我們的<code>AudioPlayer</code>是全局可見的。
    所以之後一個小小的<code>#include</code>，新隊員就打亂了整個精心設計的架構。</p>
<p>如果不用全局實例實現音頻播放器，那麼哪怕他<em>確實</em>用<code>#include</code>包含了標頭檔，他還是啥也做不了。
這種阻礙給他發送了一個明確的信號，這兩個模組不該接觸，他需要另辟蹊徑。<em>通過控制對實例的訪問，你控制了耦合。</em></p>
</li>
<li>
<p><strong>對並行不友好。</strong>
    那些在單核CPU上運行遊戲的日子已經遠去。
    哪怕完全不需要並行的優勢，現代的代碼至少應考慮在多線程環境下<em>工作</em>。
    當我們將某些東西轉為全局變數時，我們創建了一塊每個線程都能看到並訪問的內存，
    卻不知道其他線程是否正在使用那塊內存。
    這種方式帶來了死鎖，競爭狀態，以及其他很難解決的線程同步問題。</p>
</li>
</ul>
<p>像這樣的問題足夠嚇阻我們聲明全局變數了，
同理單例模式也是一樣，但是那還沒有告訴我們<em>應該</em>如何設計遊戲。
怎樣不使用全局變數構建遊戲？</p>
<p>有幾個對這個問題的答案（這本書的大部分都<em>是</em>由答案構成），
但是它們並非顯而易見。
與此同時，我們得發佈遊戲。
單例模式看起來是萬能藥。
它被寫進了一本關於面向對象設計模式的書中，因此它<em>肯定</em>是個好的設計模式，對吧？
況且我們已經借助它做了很多年軟件設計了。</p>
<p>不幸的是，它不是解藥，它是安慰劑。
如果瀏覽全局變數造成的問題列表，你會注意到單例模式解決不了其中任何一個。
因為單例<em>確實是</em>全局狀態——它只是被封裝在一個類中。</p>
<h3><a href="#它能在你只有一個問題的時候解決兩個" name="它能在你只有一個問題的時候解決兩個">它能在你只有一個問題的時候解決兩個</a></h3>
<p>在GoF對單例模式的描述中，“並且”這個詞有點奇怪。
這個模式解決了一個問題還是兩個問題呢？如果我們只有其中一個問題呢？
保證實例是唯一存在的很有用的，但是誰告訴我們要讓<em>每個人</em>都能接觸到它？
同樣，全局接觸很方便，但是必須禁止存在多個實例嗎？</p>
<p>這兩問題中的後者，便利的訪問，是使用單例模式几乎全部的原因。
想想日誌類。大部分模組都能從記錄診斷日誌中獲益。
但是，如果將<code>Log</code>類的實例傳給每個需要這個方法的函數，那就混雜了產生的數據，模糊了代碼的意圖。</p>
<p>明顯的解決方案是讓<code>Log</code>類成為單例。
每個函數都能從類那裡獲得一個實例。
但當我們這樣做時，我們無意地製造了一個奇怪的小約束。
突然之間，我們不再能創建多個日誌記錄者了。</p>
<p>起初，這不是一個問題。
我們記錄單獨的日誌檔案，所以只需要一個實例。
然後，隨著開發周期的逐次循環，我們遇到了麻煩。
每個團隊的成員都使用日誌記錄各自的診斷信息，大量的日誌傾瀉在檔案裡。
程序員需要翻過很多頁代碼來找到他關心的記錄。</p>
<p><span name="worse"></span>
我們想將日誌分散到多個檔案中來解決這點。
為了達到這點，我們得為遊戲不同的領域創造單獨的日誌記錄者：
網絡，UI，聲音，遊戲，玩法。
但是我們做不到。
<code>Log</code>類不再允許我們創建多個實例，而且調用的方式也保證了這一點：</p>
<div class="codehilite"><pre><span></span><span class="nt">Log</span><span class="o">:</span><span class="nd">:instance</span><span class="o">()</span><span class="nc">.write</span><span class="o">(</span><span class="s2">&quot;Some event.&quot;</span><span class="o">);</span>
</pre></div>


<p>為了讓<code>Log</code>類支持多個實例（就像它原來的那樣），
我們需要修改類和提及它的每一行代碼。
之前便利的訪問就不再那麼便利了。</p>
<aside name="worse">
<p>這可能更糟。想象一下你的<code>Log</code>類是在多個<em>遊戲</em>間共享的庫中。
現在，為了改變設計，需要在多組人之間協調改變，
他們中的大多數既沒有時間，也沒有動機修復它。</p>
</aside>
<h3><a href="#惰性初始化從你那裡剝奪了控制權" name="惰性初始化從你那裡剝奪了控制權">惰性初始化從你那裡剝奪了控制權</a></h3>
<p>擁有虛擬內存和軟性性能需求的PC裡，惰性初始化是一個小技巧。
遊戲則是另一種狀況。初始化系統需要消耗時間：分配內存，加載資源，等等。
如果初始化音頻系統消耗了幾百個毫秒，我們需要控制它何時發生。
如果在第一次聲音播放時惰性初始化它自己，這初始化有可能發生遊戲的高潮，導致可見的掉幀和斷續的遊戲體驗。</p>
<p><span name="fragment"></span>
同樣，遊戲通常需要嚴格管理在堆上分配的內存來避免碎片。
如果音頻系統在初始化時分配到了堆上，我們需要知道<em>何時</em>初始化發生了，
這樣我們可以控制內存待在堆的<em>哪裡</em>。</p>
<aside name="fragment">
<p><a class="pattern" href="object-pool.html">對象池模式</a>一節中有內存碎片的其他細節。</p>
</aside>
<p>因為這兩個原因，我見到的大多數遊戲都不使用惰性初始化。
相反，它們像這樣實現單例模式：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">FileSystem</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">instance_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">FileSystem</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">static</span> <span class="n">FileSystem</span> <span class="n">instance_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>這解決了惰性初始化問題，但是損失了幾個單例<em>確實</em>比原生的全局變數優良的特性。
靜態實例中，我們不能使用多態，在靜態初始化時，類也必須是可構建的。
我們也不能在不需要這個實例的時候，釋放實例所占的內存。</p>
<p><span name="static"></span>
與創建一個單例不同，這裡實際上是一個簡單的靜態類。
這並非壞事，但是如果你需要的是靜態類，為什麼不完全擺脫<code>instance()</code>方法，
直接使用靜態函數呢？調用<code>Foo::bar()</code>比<code>Foo::instance().bar()</code>更簡單，
也更明確地表明你在處理靜態內存。</p>
<aside name="static">
<p>通常使用單例而不是靜態類的理由是，
如果你後來決定將靜態類改為非靜態的，你需要修改每一個調用點。
理論上，用單例就不必那麼做，因為你可以將實例傳來傳去，像普通的實例方法一樣使用。</p>
<p>實踐中，我從未見過這種情況。
每個人都在使用<code>Foo::instance().bar()</code>。
如果我們將Foo改成非單例，我們還是得修改每一個調用點。
鑒於此，我更喜歡簡單的類和簡單的調用語法。</p>
</aside>
<h2><a href="#那該如何是好" name="那該如何是好">那該如何是好</a></h2>
<p>如果我現在達到了目標，你在下次遇到問題使用單例模式之前就會三思而後行。
但是你還是有問題需要解決。你<em>應該</em>使用什麼工具呢？
這取決於你試圖做什麼，我有一些你可以考慮的選項，但是首先……</p>
<h3><a href="#看看你是不是真正地需要類" name="看看你是不是真正地需要類">看看你是不是真正地需要類</a></h3>
<p>我在遊戲中看到的很多單例類都是“管理器”——那些類存在的意義就是照顧其他對象。
我曾看到一些代碼庫中，几乎<em>所有</em>類都有管理器：
怪物，怪物管理器，粒子，粒子管理器，聲音，聲音管理器，管理管理器的管理器。
有時候，它們被叫做“系統”或“引擎”，但是思路還是一樣的。</p>
<p>管理器類有時是有用的，但通常它們只是反映出作者對OOP的不熟悉。思考這兩個特製的類：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Bullet</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">getX</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x_</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">getY</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">y_</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">setX</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">x_</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setY</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="n">y_</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BulletManager</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Bullet</span><span class="o">*</span> <span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Bullet</span><span class="o">*</span> <span class="n">bullet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bullet</span><span class="p">();</span>
    <span class="n">bullet</span><span class="o">-&gt;</span><span class="n">setX</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">bullet</span><span class="o">-&gt;</span><span class="n">setY</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">bullet</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isOnScreen</span><span class="p">(</span><span class="n">Bullet</span><span class="o">&amp;</span> <span class="n">bullet</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">bullet</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
           <span class="n">bullet</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">SCREEN_WIDTH</span> <span class="o">&amp;&amp;</span>
           <span class="n">bullet</span><span class="p">.</span><span class="n">getY</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
           <span class="n">bullet</span><span class="p">.</span><span class="n">getY</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">SCREEN_HEIGHT</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="n">Bullet</span><span class="o">&amp;</span> <span class="n">bullet</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">bullet</span><span class="p">.</span><span class="n">setX</span><span class="p">(</span><span class="n">bullet</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>也許這個例子有些蠢，但是我見過很多代碼，在剝離了外部的細節後是一樣的設計。
如果你看看這個代碼，<code>BulletManager</code>很自然應是一個單例。
無論如何，任何有<code>Bullet</code>的對象都需要管理，而你又需要多少個<code>BulletManager</code>實例呢？</p>
<p>事實上，這裡的答案是<em>零</em>。
這裡是我們如何為管理類解決“單例”問題：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Bullet</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Bullet</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y_</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">isOnScreen</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">x_</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x_</span> <span class="o">&lt;</span> <span class="n">SCREEN_WIDTH</span> <span class="o">&amp;&amp;</span>
           <span class="n">y_</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y_</span> <span class="o">&lt;</span> <span class="n">SCREEN_HEIGHT</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">move</span><span class="p">()</span> <span class="p">{</span> <span class="n">x_</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>好了。沒有管理器，也沒有問題。
糟糕設計的單例通常會“幫助”另一個類增加代碼。
如果可以，把所有的行為都移到單例幫助的類中。
畢竟，OOP就是讓對象管理好自己。</p>
<p>但是在管理器之外，還有其他問題我們需要尋求單例模式幫助。
對於每種問題，都有一些後續方案可供參考。</p>
<h3><a href="#將類限製為單一的實例" name="將類限製為單一的實例">將類限製為單一的實例</a></h3>
<p><span name="wrapper"></span>
這是單例模式幫你解決的一個問題。
就像在檔案系統的例子中那樣，保證類只有一個實例是很重要的。
但是，這不意味著我們需要提供對實例的<em>公眾</em><em>全局</em>訪問。
我們想要減少某部分代碼的公眾部分，甚至讓它在類中是私有的。
在這些情況下，提供一個全局接觸點消弱了整體架構。</p>
<aside name="wrapper">
<p>舉個例子，我們也許想把檔案系統包在<em>另一</em>層抽象中。</p>
</aside>
<p>我們希望有種方式能保證同事只有一個實例而<em>無需</em>提供全局接觸點。
有好幾種方法能做到。這是其中之一：</p>
<p><span name="assert"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">FileSystem</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">FileSystem</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">instantiated_</span><span class="p">);</span>
    <span class="n">instantiated_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">FileSystem</span><span class="p">()</span> <span class="p">{</span> <span class="n">instantiated_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">instantiated_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="n">FileSystem</span><span class="o">::</span><span class="n">instantiated_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>


<p>這個類允許任何人構建它，如果你試圖構建超過一個實例，它會斷言並失敗。
只要正確的代碼首先創建了實例，那麼就保證了沒有其他代碼可以接觸實例或者創建自己的實例。
這個類保證滿足了它關注的單一實例，但是它沒有指定類該如何被使用。</p>
<aside name="assert">
<p><em>斷言</em> 函數是一種向你的代碼中添加限制的方法。
當<code>assert()</code>被調用時，它計算傳入的表達式。
如果結果為<code>true</code>，那麼什麼都不做，遊戲繼續。
如果結果為<code>false</code>，它立刻停止遊戲。
在debug build時，這通常會啟動調試器，或至少打印失敗斷言所在的檔案和行號。</p>
<p><code>assert()</code>表示，
“我斷言這個總該是真的。如果不是，那就是漏洞，我想<em>立刻</em>停止並處理它。”
這樣你在代碼區域之間定義約束。
如果函數斷言它的某個參數不能為<code>NULL</code>，那就是說，“我和調用者定下了協議：傳入的參數不會<code>NULL</code>。”</p>
<p>斷言幫助我們在遊戲發生預期以外的事時立刻追蹤漏洞，
而不是等到錯誤最終顯現在用戶可見的某些事物上。
它們是代碼中的柵欄，圍住漏洞，這樣漏洞就不能從製造它的代碼邊逃開。</p>
</aside>
<p>這個實現的缺點是隻在<em>運行時</em>檢查並阻止多重實例化。
單例模式，正相反，通過類的自然結構，在編譯時就能確定實例是單一的。</p>
<h3><a href="#為了給實例提供方便的訪問方法" name="為了給實例提供方便的訪問方法">為了給實例提供方便的訪問方法</a></h3>
<p>便利的訪問是我們使用單例的一個主要原因。
這讓我們在不同地方獲取需要的對象更加容易。
這種便利是需要付出代價的——在我們<em>不想</em>要對象的地方，也能輕易地使用。</p>
<p>通用原則是在能完成工作的同時，將變數寫得儘可能局部。
對象影響的範圍越小，在處理它時，我們需要放在腦子裡的東西就越少。
在我們拿起有<em>全局</em>範圍影響的單例對象前，先考慮考慮代碼中其他獲取對象的方式：</p>
<p><span name="di"></span></p>
<ul>
<li>
<p><strong>傳進來。</strong>
    最簡單的解決辦法，通常也是最好的，把你需要的對象簡單地作為參數傳給需要它的函數。
    在用其他更加繁雜的方法前，考慮一下這個解決方案。</p>
<aside name="di">

<p>有些人使用術語“依賴注入”來指代它。不是代碼<em>出來</em>調用某些全局量來確認依賴，
而是依賴通過參數被<em>傳進</em>到需要它的代碼中去。
其他人將“依賴注入”保留為對代碼提供更複雜依賴的方法。</p>
</aside>

<p>考慮渲染對象的函數。為了渲染，它需要接觸一個代表圖形設備的對象，管理渲染狀態。
將其傳給所有渲染函數是很自然的，通常是用一個名字像<code>context</code>之類的參數。</p>
<p><span name="aop"></span>
另一方面，有些對象不該在方法的參數列表中出現。
舉個例子，處理AI的函數可能也需要寫日誌檔案，但是日誌不是它的核心關注點。
看到<code>Log</code>出現在它的參數列表中是很奇怪的事情，像這樣的情況，我們需要考慮其他的選項。</p>
<aside name="aop">

<p>像日誌這樣撒佈在代碼庫各處的是“橫切關注點”(cross-cutting concern)。
小心地處理橫切關注點是架構中的持久挑戰，特別是在靜態類型語言中。</p>
<p><a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">面向切面編程</a>被設計出來應對它們。</p>
</aside>

</li>
<li>
<p><strong>從基類中獲得。</strong>
    很多遊戲架構有淺層但是寬泛的繼承層次，通常只有一層深。
    舉個例子，你也許有<code>GameObject</code>基類，每個遊戲中的敵人或者對象都繼承它。
    使用這樣的架構，很大一部分遊戲代碼會存在這些“子”推導類中。
    這就意味著這些類已經有了對同樣事物的相同獲取方法：它們的<code>GameObject</code>基類。
    我們可以利用這點：</p>
<p><span name="gameobject"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GameObject</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">Log</span><span class="o">&amp;</span> <span class="n">getLog</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">log_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">Log</span><span class="o">&amp;</span> <span class="n">log_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Enemy</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameObject</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="n">doSomething</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">getLog</span><span class="p">().</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;I can log!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>這保證任何<code>GameObject</code>之外的代碼都不能接觸<code>Log</code>對象，但是每個派生的實體確實能使用<code>getLog()</code>。
這種使用protected函數，讓派生對象使用的模式，
被涵蓋在<a class="pattern" href="subclass-sandbox.html">子類沙箱</a>這章中。</p>
<aside name="gameobject">

<p>這也引出了一個新問題，“<code>GameObject</code>是怎樣獲得<code>Log</code>實例的？”一個簡單的方案是，讓基類創建並擁有靜態實例。</p>
<p>如果你不想要基類承擔這些，你可以提供一個初始化函數傳入<code>Log</code>實例，
或使用<a class="pattern" href="service-locator.html">服務定位器</a>模式找到它。</p>
</aside>

</li>
<li>
<p><strong>從已經是全局的東西中獲取。</strong>
    移除<em>所有</em>全局狀態的目標令人欽佩，但並不實際。
    大多數代碼庫仍有一些全局可用對象，比如一個代表了整個遊戲狀態的<code>Game</code>或<code>World</code>對象。</p>
<p>我們可以讓現有的全局對象捎帶需要的東西，來減少全局變數類的數目。
不讓<code>Log</code>，<code>FileSystem</code>和<code>AudioPlayer</code>都變成單例，而是這樣做：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Game</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">Game</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">instance_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// 設置log_, et. al. ……</span>

  <span class="n">Log</span><span class="o">&amp;</span>         <span class="n">getLog</span><span class="p">()</span>         <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">log_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">FileSystem</span><span class="o">&amp;</span>  <span class="n">getFileSystem</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">fileSystem_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">AudioPlayer</span><span class="o">&amp;</span> <span class="n">getAudioPlayer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">audioPlayer_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">Game</span> <span class="n">instance_</span><span class="p">;</span>

  <span class="n">Log</span>         <span class="o">*</span><span class="n">log_</span><span class="p">;</span>
  <span class="n">FileSystem</span>  <span class="o">*</span><span class="n">fileSystem_</span><span class="p">;</span>
  <span class="n">AudioPlayer</span> <span class="o">*</span><span class="n">audioPlayer_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p><span name="demeter"></span>
這樣，只有<code>Game</code>是全局可見的。
函數可以通過它訪問其他系統。</p>
<div class="codehilite"><pre><span></span><span class="n">Game</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">getAudioPlayer</span><span class="p">().</span><span class="n">play</span><span class="p">(</span><span class="n">VERY_LOUD_BANG</span><span class="p">);</span>
</pre></div>


<aside name="demeter">

<p>純粹主義者會聲稱這違反了Demeter法則。我則聲稱這比一大坨單例要好。</p>
</aside>

<p>如果，稍後，架構被改為支持多個<code>Game</code>實例（可能是為了流處理或者測試），
<code>Log</code>，<code>FileSystem</code>，和<code>AudioPlayer</code>都不會被影響到——它們甚至不知道有什麼區別。
缺陷是，當然，更多的代碼耦合到了<code>Game</code>中。
如果一個類簡單地需要播放聲音，為了訪問音頻播放器，上例中仍然需要它知道遊戲世界。</p>
<p>我們通過混合方案解決這點。
知道<code>Game</code>的代碼可以直接從它那裡訪問<code>AudioPlayer</code>。
而不知道的代碼，我們用上面描述的其他選項來提供<code>AudioPlayer</code>。</p>
</li>
<li>
<p><strong>從服務定位器中獲得。</strong>
    目前為止，我們假設全局類是具體的類，比如<code>Game</code>。
    另一種選項是定義一個類，存在的唯一目標就是為對象提供全局訪問。
    這種常見的模式被稱為<a class="pattern" href="service-locator.html">服務定位器</a>模式，有單獨講它的章節。</p>
</li>
</ul>
<h2><a href="#單例中還剩下什麼" name="單例中還剩下什麼">單例中還剩下什麼</a></h2>
<p>剩下的問題，何處我們<em>應該</em>使用真實的單例模式？
說實話，我從來沒有在遊戲中使用全部的GoF模式。
為了保證實例是單一的，我通常簡單的使用靜態類。
如果這無效，我使用靜態標識位，在運行時檢測是不是只有一個實例被創建了。</p>
<p>書中還有一些其他章節也許能有所幫助。
<a class="pattern" href="subclass-sandbox.html">子類沙箱</a>模式通過分享狀態，
給實例以類的訪問權限而無需讓其全局可用。
<a class="pattern" href="service-locator.html">服務定位器</a>模式<em>確實</em>讓一個對象全局可用，
但它給了你如何設置對象的靈活性。</p>
<nav>
  <span class="prev">&larr; <a href="prototype.html">上一章</a></span>
  <span class="next"><a href="state.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
