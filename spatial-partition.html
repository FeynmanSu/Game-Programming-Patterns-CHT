<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-Hant-TW" lang="zh-Hant-TW">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />

<title>空間分區 &middot; Optimization Patterns &middot; 遊戲設計模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<!--
delete the font style for english.
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
-->
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="object-pool.html">上一章</a></span>
  
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
<h1>空間分區</h1>
<h1 class="book"><a href="/">遊戲設計模式</a><span class="section"><a href="optimization-patterns.html">Optimization Patterns</a></span></h1>
<h2><a href="#意圖" name="意圖">意圖</a></h2>
<p><em>將對象根據它們的位置存儲在資料結構中，來高效地定位對象。</em></p>
<h2><a href="#動機" name="動機">動機</a></h2>
<p>遊戲讓我們能拜訪其他世界，但這些世界通常和我們的世界沒有太多不同。
它們通常有和我們宇宙同樣的基礎物理和可理解性。
這就是我們為什麼會認為這些由比特和像素構建的東西是真實的。</p>
<p>我們這裡注意的虛擬事實是<em>位置</em>。遊戲世界有<em>空間</em>感，對象都在空間的某處。
它用很多種方式證明了這點。最明顯的是物理——對象移動，碰撞，交互——但是還有其他方式。
音頻引擎也許會考慮聲源和玩家的距離，越遠的聲音響聲越小。
在線交流也許侷限在較近的玩家之間。</p>
<p>這意味著遊戲引擎通常需要回答這個問題，“哪些對象在這個位置周圍？”
如果每幀都需要回答這個問題，這就會變成性能瓶頸。</p>
<h3><a href="#在戰場上的單位" name="在戰場上的單位">在戰場上的單位</a></h3>
<p>假設我們在做實時戰略遊戲。雙方成百上千的單位在戰場上撞在一起。
戰士需要揮舞刀鋒向最近的那個敵人砍去。
最簡單的處理方法是檢查每對單位，然後看看它們互相之間的距離：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">handleMelee</span><span class="p">(</span><span class="n">Unit</span><span class="o">*</span> <span class="n">units</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">numUnits</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">numUnits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">numUnits</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">units</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">()</span> <span class="o">==</span> <span class="n">units</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="n">handleAttack</span><span class="p">(</span><span class="n">units</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">units</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><span name="all"></span></p>
<p>這裡使用的是雙重循環，每個循環都會遍歷戰場上的所有單位。
這就是意味著每幀進行的檢測對數會隨著單位數量的<em>平方</em>增長。
每個附加單位都需要和之前<em>所有</em>單位的進行檢查。
如果有大量單位，這就完全失控了。</p>
<aside name="all">
<p>內層循環實際沒有遍歷所有的單位。
它只遍歷那些外部循環還沒有拜訪的對象。
這避免了比較一對單位<em>兩次</em>：A與B一次，B與A一次。
如果我們已經處理了A和B之間的碰撞，我們不必為B和A再做一次。</p>
<p>用大O術語，這還是<em>O(n&sup2;)</em> 的。</p>
</aside>
<h3><a href="#描繪戰線" name="描繪戰線">描繪戰線</a></h3>
<p>我們這裡碰到的問題是沒有指明數組中潛藏的對象順序。
為了在某個位置附近找到單位，我們需要遍歷整個數組。
現在，我們簡化一下遊戲。
不使用二維的戰<em>場</em>，想象這是個一維的戰<em>線</em>。</p>
<p><img src="images/spatial-partition-battle-line.png" alt="一條在不同坐標標記了不同單位位置的數軸。" /></p>
<p><span name="array"></span></p>
<p>在這種情況下，我們可以通過根據單位在戰線上的位置<em>排序</em>數組元素來簡化問題。
一旦我們那樣做，我們可以使用像<a href="http://en.wikipedia.org/wiki/Binary_search">二分查找</a>之類的東西找到最近的對象而不必掃瞄整個數組。</p>
<aside name="array">
<p>二分查找有<em>O(log n)</em> 的複雜度，意味著找所有戰鬥單位的複雜度從<em>O(n&sup2;)</em>降到<em>O(n log n)</em>。
像<a href="http://en.wikipedia.org/wiki/Pigeonhole_sort">pigeonhole sort</a>可將其降至<em>O(n)</em> 。</p>
</aside>
<p>這裡的經驗很明顯：如果我們根據位置存儲對象在資料結構中，就可以更快的找到它們。
這個模式便是將這個思路應用到多維空間上。</p>
<h2><a href="#模式" name="模式">模式</a></h2>
<p>對於一系列<strong>對象</strong>，每個對象都有<strong>空間上的位置</strong>。
將它們存儲在根據位置組織對象的<strong>空間資料結構</strong>中，讓你<strong>有效查詢在某處或者某處附近的對象</strong>。
當對象的位置改變時，<strong>更新空間資料結構</strong>，這樣它可以繼續找到對象。</p>
<h2><a href="#何時使用" name="何時使用">何時使用</a></h2>
<p>這是存儲活躍的，移動的遊戲對象的常用模式，也可用於靜態美術和世界地理。
複雜的遊戲中，不同的內容有不同的空間分區。</p>
<p>這個模式的基本要求是一系列有位置的對象，而你做了太多的通過位置尋找對象的查詢，導致性能下降。</p>
<h2><a href="#記住" name="記住">記住</a></h2>
<p>空間分區的存在是為了將<em>O(n)</em>或者<em>O(n&sup2;)</em> 的操作降到更加可控的數量級。
你擁有的對象<em>越多</em>，這就越重要。相反的，如果<em>n</em>足夠小，也許不需要擔心這個。</p>
<p><span name="hash-change"></span></p>
<p>由於這個模式需要通過位置組織對象，可以<em>改變</em>位置的對象更難處理。
你需要重新組織資料結構來追蹤在新位置的對象，這添加了更多的複雜性<em>並</em>消耗CPU循環。
保證這種交易是值得的。</p>
<aside name="hash-change">
<p>想象一下哈希表，其中對象的鍵可以自動改變，那你就知道為什麼這難以處理。</p>
</aside>
<p>空間分區也會因為記錄劃分的資料結構而使用額外的內存。
就像很多優化一樣，它用內存換速度。如果內存比時鐘周期更短缺，這回是個錯誤的選擇。</p>
<h2><a href="#示例代碼" name="示例代碼">示例代碼</a></h2>
<p><span name="variations"></span></p>
<p>模式總會<em>變化</em>——每種實現都略有不同，空間分區也不例外。
不像其他的模式，它的每種變化都很好地被記錄下來了。
學術界發表文章證明各種變化各自的性能優勢。
由於我只關注模式背後的觀念，我會給你展示最簡單的空間分區：<em>固定網格</em>。</p>
<aside name="variations">
<p>看看本章的最後一節，那裡有遊戲中常用的空間分區方法列表。</p>
</aside>
<h3><a href="#一張網格紙" name="一張網格紙">一張網格紙</a></h3>
<p>想象整個戰場。現在，疊加一張方格大小固定的網格在上面，就好像一張網格紙。
不是在單獨的數組中存儲我們的對象，我們將它們存到網格的格子中。
每個格子存儲一組單位，它們的位置在格子的邊界內部。</p>
<p><img src="images/spatial-partition-grid.png" alt="一個單位佔據不同格子的網格。有些格子有多個單位。" /></p>
<p>當我們處理戰鬥時，我們只需考慮在同一格子中的單位。
不是將每個遊戲中的單位與其他所有單位比較，我們將戰場<em>劃分</em>為多個小戰場，每個格子中的單位都較少。</p>
<h3><a href="#一網格相鄰單位" name="一網格相鄰單位">一網格相鄰單位</a></h3>
<p>好了，讓我們編碼把。首先，一些準備工作。這是我們的基礎<code>Unit</code>類。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Unit</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Grid</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">Unit</span><span class="p">(</span><span class="n">Grid</span><span class="o">*</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span>
    <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
    <span class="n">y_</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
  <span class="n">Grid</span><span class="o">*</span> <span class="n">grid_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>每個單位都有位置（2D表示），以及一個指針指向它存在的<code>Grid</code>。
我們讓<code>Grid</code>成為一個<code>friend</code>類，
因為，就像將要看到的，當單位的位置改變時，它需要和網格做複雜的交互，以確保所有事情都正確的更新了。</p>
<p>這裡是網格的表示：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Grid</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Grid</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 清空網格</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">NUM_CELLS</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">NUM_CELLS</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">cells_</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">NUM_CELLS</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">CELL_SIZE</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">Unit</span><span class="o">*</span> <span class="n">cells_</span><span class="p">[</span><span class="n">NUM_CELLS</span><span class="p">][</span><span class="n">NUM_CELLS</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p><span name="stl"></span></p>
<p>注意每個格子都是一個指向單位的指針。
下面我們擴展<code>Unit</code>，增加<code>next</code>和<code>prev</code>指針：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Unit</span>
<span class="p">{</span>
  <span class="c1">// 之前的代碼……</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">Unit</span><span class="o">*</span> <span class="n">prev_</span><span class="p">;</span>
  <span class="n">Unit</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>這讓我們將對象組織為<a href="http://en.wikipedia.org/wiki/Doubly_linked_list">雙向鏈表</a>，而不是數組。</p>
<p><img src="images/spatial-partition-linked-list.png" alt="一個格子指向存儲單元的雙向鏈表。" /></p>
<p>每個網格中的指針都指向網格中的元素列表的第一個，
每個對象都有個指針指向它前面的對象，以及另一個指針指向它後面的對象。
我們很快會知道為什麼要這麼做。</p>
<aside name="stl">
<p>在這本書中，我避免使用任何C++標準庫內建的集合類型。
我想讓理解例子的所需知識越小越好，然後，就像魔術師的“我的袖子裡什麼也沒有”，
我想明晰代碼中<em>確實</em>在發生什麼。
細節很重要，特別是那些與性能相關的模式。</p>
<p>但這是我<em>解釋</em>模式的方式。
如果你在真實代碼中<em>使用</em>它們，使用內建在几乎每種程序語言集合避免麻煩。
人生苦短，不要浪費在編寫鏈表上。</p>
</aside>
<h3><a href="#進入戰場" name="進入戰場">進入戰場</a></h3>
<p>我們需要做的第一件事就是保證新單位創建時被放置到了網格中。
我們讓<code>Unit</code>在它的建構子中處理這個：</p>
<div class="codehilite"><pre><span></span><span class="n">Unit</span><span class="o">::</span><span class="n">Unit</span><span class="p">(</span><span class="n">Grid</span><span class="o">*</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
<span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span>
  <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
  <span class="n">y_</span><span class="p">(</span><span class="n">y</span><span class="p">),</span>
  <span class="n">prev_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span>
  <span class="n">next_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">grid_</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p><code>add()</code>方法像這樣定義：</p>
<p><span name="floor"></span></p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Grid</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="n">Unit</span><span class="o">*</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 檢測它在哪個網格中</span>
  <span class="kt">int</span> <span class="n">cellX</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">unit</span><span class="o">-&gt;</span><span class="n">x_</span> <span class="o">/</span> <span class="n">Grid</span><span class="o">::</span><span class="n">CELL_SIZE</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">cellY</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">unit</span><span class="o">-&gt;</span><span class="n">y_</span> <span class="o">/</span> <span class="n">Grid</span><span class="o">::</span><span class="n">CELL_SIZE</span><span class="p">);</span>

  <span class="c1">// 加到網格的對象列表前段</span>
  <span class="n">unit</span><span class="o">-&gt;</span><span class="n">prev_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">cells_</span><span class="p">[</span><span class="n">cellX</span><span class="p">][</span><span class="n">cellY</span><span class="p">];</span>
  <span class="n">cells_</span><span class="p">[</span><span class="n">cellX</span><span class="p">][</span><span class="n">cellY</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="o">-&gt;</span><span class="n">prev_</span> <span class="o">=</span> <span class="n">unit</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<aside name="floor">
<p>世界坐標除以網格大小轉換到了網格空間。
然後，縮短為<code>int</code>消去了分數部分，這樣可以獲得網格索引。</p>
</aside>
<p>除了鏈錶帶來的繁瑣，基本思路是非常簡單的。
我們找到單位所在的網格，然後將它添加到列表前部。
如果那已經存在有列表單位了，我們把新單位連結到舊單位的後面。</p>
<h3><a href="#刀劍碰撞" name="刀劍碰撞">刀劍碰撞</a></h3>
<p>一旦所有的單位都放入網格中，我們可以讓它們開始互相交互。
使用這個新網格，處理戰斗的主要方法看上去是這樣的：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Grid</span><span class="o">::</span><span class="n">handleMelee</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">NUM_CELLS</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">NUM_CELLS</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">handleCell</span><span class="p">(</span><span class="n">cells_</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>它在每個網格它上面遍歷並調用<code>handleCell()</code>。
就像你看到的那樣，我們真的已經將戰場分割為分離的小衝突。
每個網格之後像這樣處理它的戰鬥：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Grid</span><span class="o">::</span><span class="n">handleCell</span><span class="p">(</span><span class="n">Unit</span><span class="o">*</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">unit</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Unit</span><span class="o">*</span> <span class="n">other</span> <span class="o">=</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">other</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">unit</span><span class="o">-&gt;</span><span class="n">x_</span> <span class="o">==</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">x_</span> <span class="o">&amp;&amp;</span>
          <span class="n">unit</span><span class="o">-&gt;</span><span class="n">y_</span> <span class="o">==</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">y_</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">handleAttack</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><span name="nested"></span></p>
<p>除了遍歷鏈表的指針把戲，注意它和我們原先處理戰斗的原始方法完全一樣。
它對比每對單位，看看它們是否在同一位置。</p>
<p>不同之處是，我們不必再互相比較戰場上<em>所有的</em>單位——只與那些近在一個格子中的相比較。
這就是優化的核心。</p>
<aside name="nested">
<p>簡單分析一下，似乎我們讓性能<em>更糟</em>了。
我們從對單位的雙重循環變成了對格子內單位的<em>三重</em>循環。
這裡的技巧是內部循環現在只在很少的單位上運行，這足夠抵消在格子上的外部循環的代價。</p>
<p>但是，這依賴於我們格子的粒度。如果它們太小，外部循環確實會造成影響。</p>
</aside>
<h3><a href="#衝鋒陷陣" name="衝鋒陷陣">衝鋒陷陣</a></h3>
<p>我們解決了性能問題，但同時創建了新問題。
單位現在陷在它的格子中。
如果將單位移出了包含它的格子，格子中的單位就再也看不到它了，但其他單位也看不到它。
我們的戰場有點<em>過度</em>劃分了。</p>
<p>為瞭解決這點，需要每次單位移動時都做些工作。
如果它跨越了格子的邊界，我們需要將它從原來的格子中刪除，添加到新的格子中。
首先，我們給<code>Unit</code>添加一個改變位置的方法：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Unit</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">grid_</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>顯而易見，AI代碼可以調用它來控制電腦的單位，玩家也可以輸入代碼調用它來控制玩家的單位。
它做的只是交換格子的控制權，之後：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Grid</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Unit</span><span class="o">*</span> <span class="n">unit</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 看看它現在在哪個網格中</span>
  <span class="kt">int</span> <span class="n">oldCellX</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">unit</span><span class="o">-&gt;</span><span class="n">x_</span> <span class="o">/</span> <span class="n">Grid</span><span class="o">::</span><span class="n">CELL_SIZE</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">oldCellY</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">unit</span><span class="o">-&gt;</span><span class="n">y_</span> <span class="o">/</span> <span class="n">Grid</span><span class="o">::</span><span class="n">CELL_SIZE</span><span class="p">);</span>

  <span class="c1">// 看看它移動向哪個網格</span>
  <span class="kt">int</span> <span class="n">cellX</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">x</span> <span class="o">/</span> <span class="n">Grid</span><span class="o">::</span><span class="n">CELL_SIZE</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">cellY</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">y</span> <span class="o">/</span> <span class="n">Grid</span><span class="o">::</span><span class="n">CELL_SIZE</span><span class="p">);</span>

  <span class="n">unit</span><span class="o">-&gt;</span><span class="n">x_</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">unit</span><span class="o">-&gt;</span><span class="n">y_</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

  <span class="c1">// 如果它沒有改變網格，就到此為止</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">oldCellX</span> <span class="o">==</span> <span class="n">cellX</span> <span class="o">&amp;&amp;</span> <span class="n">oldCellY</span> <span class="o">==</span> <span class="n">cellY</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="c1">// 將它從老網格的列表中移除</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">unit</span><span class="o">-&gt;</span><span class="n">prev_</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">unit</span><span class="o">-&gt;</span><span class="n">prev_</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="o">-&gt;</span><span class="n">prev_</span> <span class="o">=</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">prev_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 如果它是列表的頭，移除它</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cells_</span><span class="p">[</span><span class="n">oldCellX</span><span class="p">][</span><span class="n">oldCellY</span><span class="p">]</span> <span class="o">==</span> <span class="n">unit</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cells_</span><span class="p">[</span><span class="n">oldCellX</span><span class="p">][</span><span class="n">oldCellY</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 加到新網格的對象列表末尾</span>
  <span class="n">add</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>這塊代碼很長但也很直觀。
第一步檢查我們是否穿越了格子的邊界。
如果沒有，需要做的事情就是更新單位的位置，搞定。</p>
<p>如果單位<em>已經</em>離開了現在的格子，我們從格子的鏈表中移除它，然後再添加到網格中。
就像添加一個新單位，它會插入新格子的鏈表中。</p>
<p>這就是為什麼我們使用雙向鏈表——我們可以通過設置一些指針飛快地添加和刪除單位。
每幀都有很多單位移動時，這就很重要了。</p>
<h3><a href="#短兵相接" name="短兵相接">短兵相接</a></h3>
<p>這看起來很簡單，但我們某種程度上作弊了。
在我展示的例子中，單位在它們有<em>完全相同的</em>位置時才進行交互。
西洋棋和國際象棋中這是真的，但是對於更加實際的遊戲就不那麼準確了。
它們通常需要將攻擊<em>距離</em>引入考慮。</p>
<p>這個模式仍然可以好好工作，與檢查位置匹配不同，我們這樣做：</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ATTACK_DISTANCE</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">handleAttack</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>當範圍被牽扯進來，需要考慮一個邊界情況：
在不同網格的單位也許仍然足夠接近，可以相互交互。</p>
<p><img src="images/spatial-partition-adjacent.png" alt="兩個在相鄰網格的對象近得足以相互交互。" /></p>
<p>這裡，B在A的攻擊半徑內，即使中心點在不同的網格。
為了處理這種情況，我們不僅需要比較同一網格的單位，同時需要比較鄰近網格的對象。
為了達到這點，首先我們讓內層循環擺脫<code>handleCell()</code>：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Grid</span><span class="o">::</span><span class="n">handleUnit</span><span class="p">(</span><span class="n">Unit</span><span class="o">*</span> <span class="n">unit</span><span class="p">,</span> <span class="n">Unit</span><span class="o">*</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">other</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ATTACK_DISTANCE</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">handleAttack</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>現在有函數接受一個單位和一列表的其他單位看看有沒有碰撞。
讓<code>handleCell()</code>使這個函數：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Grid</span><span class="o">::</span><span class="n">handleCell</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Unit</span><span class="o">*</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">cells_</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">unit</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 處理同一網格中的其他單位</span>
    <span class="n">handleUnit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">);</span>

    <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>注意我們同樣傳入了網格的坐標，而不僅僅是對象列表。
現在，這也許和前面的例子沒有什麼區別，但是我們會稍微擴展一下：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Grid</span><span class="o">::</span><span class="n">handleCell</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Unit</span><span class="o">*</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">cells_</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">unit</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 處理同一網格中的其他單位</span>
    <span class="n">handleUnit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">);</span>

    <span class="c1">// 同樣檢測近鄰網格</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">handleUnit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">cells_</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">handleUnit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">cells_</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">handleUnit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">cells_</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">NUM_CELLS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">handleUnit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">cells_</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><span name="neighbor"></span></p>
<p>這些新增<code>handleCell()</code>調用在八個鄰近格子中的四個格子中尋找這個單位是否與它們有任何對抗。
如果任何鄰近格子的單位離邊緣近到單位的攻擊半徑內，就找到碰撞了。</p>
<aside name="neighbor">
<p>有單位的格子是<code>U</code>，它查找的鄰近格子是<code>X</code>。</p>
<p><img src="images/spatial-partition-neighbors.png" width="240" alt="八個內鄰格子，其中四個被標亮了。" /></p>
</aside>
<p>我們只查詢<em>一半</em>的近鄰格子，這原因和之前是一樣的：內層循環從當前單位<em>之後</em>的單位開始——避免每對單位比較兩次。
考慮如果我們檢查全部八個近鄰格子會發生什麼。</p>
<p>假設我們有兩個在鄰近格子的單位近到可以互相攻擊，就像前一個例子。
這是我們檢查全部8個格子會發生的事情：</p>
<ol>
<li>當找誰打了A時，我們檢查它的右邊找到了B。所以記錄一次A和B之間的攻擊。</li>
<li>當找誰打了B時，我們檢查它的<em>左邊</em>找到了A。所以記錄<em>第二次</em>A和B之間的攻擊。</li>
</ol>
<p>只檢查一半的近鄰格子修復了這點。檢查<em>哪一</em>半倒無關緊要。</p>
<p>我們還需要考慮另外的邊界情況。
這裡，我們假設最大攻擊距離小於一個格子。
如果我們有較小的小格子和較長的攻擊距離，我們也許需要掃瞄幾行外的近鄰格子。</p>
<h2><a href="#設計決策" name="設計決策">設計決策</a></h2>
<p>空間劃分的優秀資料結構相對較少，可以一一列舉進行介紹。
但是，我試圖根據它們的本質特性來組織。
我期望當你學習四叉樹和二分空間查找（BSPs）之類的時，
可以幫助你理解它們是<em>如何</em>工作，<em>為什麼</em> 工作，以幫你選擇。</p>
<h3><a href="#劃分是層次的還是平面的？" name="劃分是層次的還是平面的？">劃分是層次的還是平面的？</a></h3>
<p><span name="couple"></span></p>
<p>我們的網格例子將空間劃分成平面格子的集合。
相反，層次空間劃分將空間分成幾個區域。
然後，如果其中一個區域還包含多個對象，再劃分它。
這個過程遞歸進行，直到每個區域都有少於最大數量的對象在其中。</p>
<aside name="couple">
<p>它們通常分為2,4,8塊——程序員很熟悉這些數值。</p>
</aside>
<ul>
<li>
<p><strong>如果是平面劃分：</strong></p>
<p><span name="simpler"></span></p>
<ul>
<li>
<p><em>更簡單。</em>
平面資料結構更容易想到也更容易實現。</p>
<aside name="simpler">

<p>我在每章中都提到了這個設計要點，這是有理由的。儘可能使用簡單的選項。
大多數軟件工程都是與複雜度做鬥爭。</p>
</aside>

</li>
<li>
<p><em>內存使用量確定。</em>
由於添加新對象不需要添加新劃分，空間分區的內存使用量通常在之前就可以確定。</p>
</li>
<li>
<p><em>在對象改變位置時更新的更快。</em>
當對象移動，資料結構需要更新，找到它的新位置。
使用層次空間分區，可能需要在多層間調整層次結構。</p>
</li>
</ul>
</li>
<li>
<p><strong>如果是層次性的：</strong></p>
<ul>
<li>
<p><em>能更有效率的處理空的區域。</em>
考慮之前的例子，如果戰場的一邊是空的。
我們需要分配一堆空白格子，這些格子浪費內存，每幀還要遍歷它們。</p>
<p>由於層次空間分區不再分割空區域，大的空區域保存在單個劃分上。不需要遍歷很多小空間，那裡只有一個大的。</p>
</li>
<li>
<p><em>它處理密集空間更有效率。</em>
這是硬幣的另一面：如果你有一堆對象堆在一起，無層次的劃分很沒有效率。
你最終將所有對象都劃分到了一起，就跟沒有劃分一樣。
層次空間分區會自適應地劃成小塊，讓你同時只需考慮少數對象。</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#劃分依賴于對象集合嗎？" name="劃分依賴于對象集合嗎？">劃分依賴于對象集合嗎？</a></h3>
<p>在示例代碼中，網格空間大小事先被固定了，我們在格子裡追蹤單位。
另外的劃分策略是自適應的——它們根據現有的對象集合在世界中的位置劃分邊界。</p>
<p>目標是<em>均勻地</em>劃分，每個區域擁有相同的單位數量，以獲得最好性能。
考慮網格的例子，如果所有的單位都擠在戰場的一個角落裡。
它們都會在同一格子中，找尋單位間攻擊的代碼退化為原來的<em>O(n&sup2;)</em> 問題。</p>
<ul>
<li>
<p><strong>如果劃分與對象無關：</strong></p>
<ul>
<li><em>對象可以增量添加。</em>
 添加對象意味著找到正確的劃分然後放入，這點可以一次性完成，沒有任何性能問題。</li>
</ul>
<p><span name="sort"></span></p>
<ul>
<li>
<p><em>對象移動的更快。</em>
通過固定的劃分，移動單位意味著從格子移除然後添加到另一個。
如果劃分它們的邊界跟著集合而改變，那麼移動對象會引起邊界移動，導致很多其他對象也要移到其他劃分。</p>
<aside name="sort">

<p>這可與如紅黑樹或AVL樹這樣的二叉搜索樹相類比：
當你添加事物時，你也許最終需要重排樹，並重排一堆節點。</p>
</aside>

</li>
<li>
<p><em>劃分也許不均勻。</em>
當然，固定的缺點就是對劃分缺少控制。如果對象擠在一起，你就在空區域上浪費了內存，這會造成更糟的性能。</p>
</li>
</ul>
</li>
<li>
<p><strong>如果劃分適應對象集合：</strong></p>
<p>像BSPs和k-d樹這樣的空間劃分切分世界，讓每部分都包含接近相同數目的對象。
為了做到這點，劃分邊界時，你需要計算每邊各有多少對象。
層次包圍盒是另外一種為特定集合對象優化的空間分區。</p>
<ul>
<li>
<p><em>你可以保證劃分是平衡的。</em>
這不僅提供了優良的性能表現，還提供了<em>穩定</em>的性能表現：
如果每個區域的對象數量保持一致，你可以保證遊戲世界中的所有查詢都會消耗同樣的時間。
一旦你需要固定幀率，這種一致性也許比性能本身更重要。</p>
</li>
<li>
<p><em>一次性劃分一組對象更加有效率。</em>
當對象<em>集合</em>影響了邊界的位置，最好在劃分前都出現所有對象。
這就是為什麼美術和地理更多的使用這種劃分。</p>
</li>
</ul>
</li>
<li>
<p><strong>如果劃分與對象無關，但<em>層次</em>與對象相關：</strong></p>
<p><span name="quad"></span></p>
<p>有一種空間分區需要特殊注意，因為它擁有固定分區和適應分區兩者的優點：四叉樹。</p>
<aside name="quad">

<p>四叉樹劃分二維空間。它的三維實現是<em>八叉樹</em>，獲取“空間”，分割為8個<em>正方體</em>。
除了有額外的維度，它和平面劃分一樣工作。</p>
</aside>

<p>四叉樹開始時將整個空間視為單一的劃分。
如果空間中對象數目超過了臨界值，它將其切為四小塊。
這些塊的<em>邊界</em>是確定的：它們總是將空間一切為二。</p>
<p>然後，對於四個區域中的每一個，我們遞歸地做相同的事情，直到每個區域都有較少數目的對象在其中。
由於我們遞歸地分割有較多對象的區域，這種劃分適應了對象集合，但是劃分本身沒有<em>移動</em>。</p>
<p>你可以從這裡從左向右看到分區的過程：</p>
<p><img src="images/spatial-partition-quadtree.png" alt="一個四叉樹" /></p>
<ul>
<li>
<p><em>對象可以增量增加。</em>
添加新對象意味著找到並添加到正確的區域。
如果區域中的對象數目超過了最大限度，就劃分區域。
區域中的其他對象也劃分到新的小區域中。這需要一些小小的工作，但是工作總量是<em>固定的</em>：
你需要移動的對象數目總是少於數目臨界值。添加對象從來不會引發超過一次劃分。</p>
<p>刪除對象也同樣簡單。
你從它的格子中移除對象，如果它的父格子中的計數少於臨界值，你可以合併這些子分區。</p>
</li>
<li>
<p><em>移動對象很快。</em>
當然，如上所述，“移動”對象只是添加和移除，兩者在四叉樹中都很快。</p>
</li>
<li>
<p><em>分區是平衡的。</em>
由於任何給定的區域的對象數目都少於最大的對象數量，哪怕對象都堆在一起，你也不會有包含太多對象的分區。</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#對象只存儲在分區中嗎？" name="對象只存儲在分區中嗎？">對象只存儲在分區中嗎？</a></h3>
<p>你可將空間分區作為在遊戲中對象存儲的<em>唯一</em>地方，或者將其作為更快查找的二級緩存，使用另一個集合包含對象。</p>
<ul>
<li>
<p><strong>如果它是對象唯一存儲的地方：</strong></p>
<ul>
<li><em>這避免了內存開銷和兩個集合帶來的複雜度。</em>
當然，存儲對象一遍總比存兩遍來的輕鬆。
同樣，如果你有兩個集合，你需要保證它們同步。
每當添加或刪除對象，都得從兩者中添加或刪除對象。</li>
</ul>
</li>
<li>
<p><strong>如果其他集合保存對象：</strong></p>
<ul>
<li>
<p><em>遍歷所有的對象更快。</em>
如果所有對象都是“活的”，而且它們需要做些處理，也許會發現你需要頻繁拜訪每個對象而並不在乎它的位置。
想想看，早先的例子中，大多數格子都是空的。訪問那些空的格子是對時間的浪費。</p>
<p>存儲對象的第二集合給了你直接遍歷對象的方法。
你有兩個資料結構，每種為各種的用況優化。</p>
</li>
</ul>
</li>
</ul>
<h2><a href="#參見" name="參見">參見</a></h2>
<ul>
<li>
<p>在這裡，我試圖不討論特定的空間分區結構細節來保證這章的高層概況性（而且節約篇幅！），
但你的下一步應該是學習一下常見的結構。儘管名字很恐怖，它們都令人驚訝的直觀。常見的有：</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Grid_(spatial_index)">Grid</a></li>
<li><a href="http://en.wikipedia.org/wiki/Quad_tree">Quadtree</a></li>
<li><a href="http://en.wikipedia.org/wiki/Binary_space_partitioning">BSP</a></li>
<li><a href="http://en.wikipedia.org/wiki/Kd-tree">k-d tree</a></li>
<li><a href="http://en.wikipedia.org/wiki/Bounding_volume_hierarchy">Bounding volume hierarchy</a></li>
</ul>
</li>
<li>
<p>每種空間分區資料結構基本上都是將一維資料結構擴展成更高維度的資料結構。
知道它的相互關係有助于分辨它是不是問題的好解答：</p>
<ul>
<li>網格是連續的<a href="http://en.wikipedia.org/wiki/Bucket_sort">桶排序</a>。</li>
<li>BSPs，k-d trees和包圍盒是<a href="http://en.wikipedia.org/wiki/Binary_search_tree">線性搜索樹</a>。</li>
<li>四叉樹和八叉樹是<a href="http://en.wikipedia.org/wiki/Trie">多叉樹</a>。</li>
</ul>
</li>
</ul>
<nav>
  <span class="prev">&larr; <a href="object-pool.html">上一章</a></span>
  
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
