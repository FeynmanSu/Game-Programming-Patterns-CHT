<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />

<title>遊戲循環 &middot; Sequencing Patterns &middot; 遊戲設計模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<!--
delete the font style for english.
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
-->
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="double-buffer.html">上一章</a></span>
  <span class="next"><a href="update-method.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
<h1>遊戲循環</h1>
<h1 class="book"><a href="/">遊戲設計模式</a><span class="section"><a href="sequencing-patterns.html">Sequencing Patterns</a></span></h1>
<h2><a href="#意圖" name="意圖">意圖</a></h2>
<p><em>將遊戲的進行和玩家輸入解耦，和處理器速度解耦。</em></p>
<h2><a href="#動機" name="動機">動機</a></h2>
<p>如果本書中有一個不可或缺模式，那非這個模式莫屬了。
遊戲循環是“遊戲設計模式”的精髓。
几乎每個遊戲都有，兩兩不同，而在非遊戲的程序几乎沒有使用。</p>
<p><span name="beard"></span>
為了看看它多有用，讓我們快速緬懷一遍往事。
每個編寫計算機程序的人都留著鬍子的時代，程序像洗碗機一樣工作。
你輸入一堆代碼，按個按鈕，等待，然後獲得結果，完成。
程序全都是<em>批處理模式</em>的——一旦工作完成，程序就停止了。</p>
<aside name="beard">
<p>Ada Lovelace和Rear Admiral Grace Hopper是女程序員，並沒有鬍子。</p>
</aside>
<p>你在今日仍然能看到這些程序，雖然感謝上天，我們不必在打孔紙上面編寫它們了。
終端腳本，命令行程序，甚至將Markdown翻譯成這本書的Python腳本都是批處理程序。</p>
<h3><a href="#採訪cpu" name="採訪cpu">採訪CPU</a></h3>
<p>最終，程序員意識到將批處理代碼留在計算辦公室，等幾個小時後拿到結果才能開始找程序漏洞的方式實在低效。
他們想要立即的反饋。<em>互動式</em> 程序誕生了。
第一批互動式程序中的就有遊戲：</p>
<p><span name="cave"></span></p>
<div class="codehilite"><pre><span></span>YOU ARE STANDING AT THE END OF A ROAD BEFORE A SMALL BRICK
BUILDING . AROUND YOU IS A FOREST. A SMALL
STREAM FLOWS OUT OF THE BUILDING AND DOWN A GULLY.

&gt; GO IN
YOU ARE INSIDE A BUILDING, A WELL HOUSE FOR A LARGE SPRING.
</pre></div>


<aside name="cave">
<p>這是<a href="http://en.wikipedia.org/wiki/Colossal_Cave_Adventure">Colossal Cave Adventure</a>，史上首個冒險遊戲。</p>
</aside>
<p>你可以和這個程序進行實時交互。
它等待你的輸入，然後進行響應。
你再輸入，這樣一唱一和，就像相聲一樣。
當輪到你時，它停在那裡啥也不做。像這樣：</p>
<p><span name="exit"></span></p>
<div class="codehilite"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">command</span> <span class="o">=</span> <span class="n">readCommand</span><span class="p">();</span>
  <span class="n">handleCommand</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<aside name="exit">
<p>這程序會永久循環，所以沒法退出遊戲。
真實的遊戲會做些<code>while (!done)</code>進行檢查，然後通過設置<code>done</code>為真來退出遊戲。
我省去了那些，保持簡明。</p>
</aside>
<h3><a href="#事件循環" name="事件循環">事件循環</a></h3>
<p>如果你剝開現代的圖形UI的外皮，會驚訝地發現它們與老舊的冒險遊戲差不多。
文本處理器通常獃在那裡什麼也不做，直到你按了個鍵或者點了什麼東西：</p>
<div class="codehilite"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Event</span><span class="o">*</span> <span class="n">event</span> <span class="o">=</span> <span class="n">waitForEvent</span><span class="p">();</span>
  <span class="n">dispatchEvent</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p><span name="idle"></span>
這與冒險遊戲主要的不同是，程序不是等待<em>文本指令</em>，而是等待<em>用戶輸入事件</em>——滑鼠點擊、按鍵按下之類的。
其他部分還是和以前的老式文本冒險遊戲一樣，程序<em>阻塞</em>等待用戶的輸入，這是個問題。</p>
<p>不像其他大多數軟件，遊戲即使沒有玩家輸入時也繼續運行。
如果你站在那裡看著屏幕，遊戲不會凍結。動畫繼續動著。視覺效果繼續閃爍。
如果不幸的話，怪物繼續吞噬你的英雄。</p>
<aside name="idle">
<p>件循環有“空轉”事件，這樣你可以無需用戶輸入間歇地做些事情。
對於閃爍的光標或者進度條已經足夠了，但對於遊戲就太原始了。</p>
</aside>
<p>這是真實遊戲循環的第一個關鍵部分：<em>它處理用戶輸入，但是不等待它</em>。循環總是繼續旋轉：</p>
<div class="codehilite"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">processInput</span><span class="p">();</span>
  <span class="n">update</span><span class="p">();</span>
  <span class="n">render</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p><span name="update"></span>
我們之後會改善它，但是基本的部分都在這裡了。
<code>processInput()</code>處理上次調用到現在的任何輸入。
然後<code>update()</code></span>讓遊戲模擬一步。
運行AI和物理（通常是這種順序）。
最終，<code>render()</code>繪製遊戲，這樣玩家可以看到發生了什麼。</p>
<aside name="update">
<p>就像你可以從名字中猜到的，
<code>update()</code>是使用<a href="update-method.html" class="pattern">更新方法</a>模式的好地方。</p>
</aside>
<h3><a href="#時間之外的世界" name="時間之外的世界">時間之外的世界</a></h3>
<p><span name="tick"></span>
如果這個循環沒有因為輸入而阻塞，這就帶來了明顯的問題，要運轉<em>多快</em>呢？
每次進行遊戲循環都會推動一定的遊戲狀態的發展。
在遊戲世界的居民看來，他們手上的表就會滴答一下。</p>
<aside name="tick">
<p>運行遊戲循環一次的常用術語就是“滴答”(tick)和“幀”(frame)。</p>
</aside>
<p>同時，<em>玩家的</em> 真實手錶也在滴答著。
如果我們用實際時間來測算遊戲循環運行的速度，就得到了遊戲的“幀率”(FPS)。
如果遊戲循環的更快，FPS就更高，遊戲運行的更流暢更快。
如果循環得過慢，遊戲看上去就像是慢動作電影。</p>
<p>我們現在寫的這個循環是能轉多快轉多快，兩個因素決定了幀率。
一個是<em>每幀要做多少工作</em>。複雜的物理，眾多遊戲對象，圖形細節都讓CPU和GPU繁忙，這決定了需要多久能完成一幀。</p>
<p>另一個是<em>底層平台的速度。</em> 更快的晶片可以在同樣的時間裡執行更多的代碼。
多核，GPU組，獨立音效卡，以及系統的調度都影響了在一次滴答中能夠做多少東西。</p>
<h3><a href="#每秒的幀數" name="每秒的幀數">每秒的幀數</a></h3>
<p>在早期的視頻遊戲中，第二個因素是固定的。
如果你為NES或者Apple IIe寫遊戲，你<em>明確</em>知道遊戲運行在什麼CPU上。
你可以（也必須）為它特製代碼。
你只需擔憂第一個因素：每次滴答要做多少工作。</p>
<p><span name="turbo"></span></p>
<p>早期的遊戲被仔細地編碼，一幀只做一定的工作，開發者可以讓遊戲以想要的速率運行。
但是如果你想要在快些或者慢些的機器</span>上運行同一遊戲，遊戲本身就會加速或減速。</p>
<aside name="turbo">
<p>這就是為什麼老式計算機通常有“<a href="http://en.wikipedia.org/wiki/Turbo_button">turbo</a>”按鈕。
新的計算機運行得太快了，無法玩老遊戲，因為遊戲也會運行的過快。
<em>關閉</em> turbo按鈕，會減慢計算機的運行速度，就可以運行老遊戲了。</p>
</aside>
<p>現在，很少有開發者可以奢侈地知道遊戲運行的硬件條件。遊戲必須自動適應多種設備。</p>
<p>這就是遊戲循環的另一個關鍵任務：<em>不管潛在的硬件條件，以固定速度運行遊戲。</em></p>
<h2><a href="#模式" name="模式">模式</a></h2>
<p>一個<strong>遊戲循環</strong>在遊玩中不斷運行。
每一次循環，它無阻塞地<strong>處理玩家輸入</strong>，<strong>更新遊戲狀態</strong>，<strong>渲染遊戲</strong>。
它追蹤時間的消耗並<strong>控制遊戲的速度。</strong></p>
<h2><a href="#何時使用" name="何時使用">何時使用</a></h2>
<p>使用錯誤的模式比不使用模式更糟，所以這節通常告誡你不要過于熱衷設計模式。
設計模式的目標不是往代碼庫裡儘可能的塞東西。</p>
<p><span name="engine"></span>
但是這個模式有所不同。我可以很自信的說你<em>會</em>使用這個模式。
如果你使用遊戲引擎，你不需要自己編寫，但是它還在那裡。</p>
<aside name="engine">
<p>對於我，這是“引擎”與“庫”的不同之處。
使用庫時，你擁有遊戲循環，調用庫代碼。
使用引擎時，引擎擁有遊戲循環，調用<em>你的</em>代碼。</p>
</aside>
<p>你可能認為在做回合制遊戲時不需要它。
但是哪怕是那裡，就算<em>遊戲狀態</em>到玩家回合才改變，<em>視覺</em>和<em>聽覺</em> 狀態仍會改變。
哪怕遊戲在“等待”你進行你的回合，動畫和音樂也會繼續運行。</p>
<h2><a href="#記住" name="記住">記住</a></h2>
<p><span name="percent"></span>
我們這裡談到的循環是遊戲代碼中最重要的部分。
有人說程序會花費90%的時間在10%的代碼上。
遊戲循環代碼肯定在這10%中。
你必須小心謹慎，時時注意效率。</p>
<aside name="percent">
<p>“真正的”工程師，比如機械或電子工程師，不把我們當回事，大概就是因為我們像這樣使用統計學是。</p>
</aside>
<h3><a href="#你也許需要與平台的事件循環相協調" name="你也許需要與平台的事件循環相協調">你也許需要與平台的事件循環相協調</a></h3>
<p>如果你在操作系統的頂層或者有圖形UI和內建事件循環的平台上構建遊戲，
那你就有了兩個應用循環在同時運作。
它們需要很好的協調。</p>
<p>有時候，你可以進行控制，只運行你的遊戲循環。
舉個例子，如果捨棄了Windows的珍貴API，<code>main()</code>可以只用遊戲循環。
其中你可以調用<code>PeekMessage()</code>來處理和分發系統的事件。
不像<code>GetMessage()</code>，<code>PeekMessage()</code>不會阻塞等待用戶輸入，
因此你的遊戲循環會保持運作。</p>
<p>其他的平台不會讓你這麼輕鬆地擺脫事件循環。
如果你使用網頁瀏覽器作為平台，事件循環已被內建在瀏覽器的執行模型深處。
這樣，你得用事件循環作為遊戲循環。
你會調用<code>requestAnimationFrame()</code>之類的函數，它會回調你的代碼，保持遊戲繼續運行。</p>
<h2><a href="#示例代碼" name="示例代碼">示例代碼</a></h2>
<p>在如此長的介紹之後，遊戲循環的代碼實際上很直觀。
我們會瀏覽一堆變種，比較它們的好處和壞處。</p>
<p>遊戲循環驅動了AI，渲染和其他遊戲系統，但這些不是模式的要點，
所以我們會調用虛構的方法。在實現了<code>render()</code>，<code>update()</code>之後，
剩下的作為給讀者練習（挑戰！）。</p>
<h3><a href="#跑，能跑多快跑多快" name="跑，能跑多快跑多快">跑，能跑多快跑多快</a></h3>
<p>我們已經見過了可能是最簡單的遊戲循環：</p>
<div class="codehilite"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">processInput</span><span class="p">();</span>
  <span class="n">update</span><span class="p">();</span>
  <span class="n">render</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>它的問題是你不能控制遊戲運行的有多快。
在快速機器上，循環會運行的太快，玩家看不清發生了什麼。
在慢速機器上，遊戲慢的跟在爬一樣。
如果遊戲的一部分有大量內容或者做了很多AI或物理運算，遊戲就會慢一些。</p>
<h3><a href="#休息一下" name="休息一下">休息一下</a></h3>
<p><span name="16"></span>
我們看看增加一個簡單的小修復如何。
假設你想要你的遊戲以60FPS運行。這樣每幀大約16毫秒。
只要你用少於這個時長進行遊戲所有的處理和渲染，就可以以穩定的幀率運行。
你需要做的就是處理這一幀然後<em>等待</em>，直到處理下一幀的時候，就像這樣：</p>
<p><img src="images/game-loop-simple.png" alt="一個簡單的遊戲循環流程圖。處理輸入 &rarr; 更新遊戲 &rarr; 渲染 &rarr; 等待，然後從頭開始。" /></p>
<p>代碼看上去像這樣：</p>
<aside name="16">
<p><em>1000 毫秒 / 幀率 = 毫秒每幀</em>.</p>
</aside>
<div class="codehilite"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">getCurrentTime</span><span class="p">();</span>
  <span class="n">processInput</span><span class="p">();</span>
  <span class="n">update</span><span class="p">();</span>
  <span class="n">render</span><span class="p">();</span>

  <span class="n">sleep</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">MS_PER_FRAME</span> <span class="o">-</span> <span class="n">getCurrentTime</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<p>如果它很快的處理完一幀，這裡的<code>sleep()</code>保證了遊戲不會運行太<em>快</em>。
如果你的遊戲運行太<em>慢</em>，這無濟於事。
如果需要超過16ms來更新並渲染一幀，休眠的時間就變成了<em>負的</em>。
如果計算機能回退時間，很多事情就很容易了，但是它不能。</p>
<p>相反，遊戲變慢了。
可以通過每幀少做些工作來解決這個問題——減少物理效果和絢麗光影，或者把AI變笨。
但是這影響了那些有快速機器的玩家的遊玩體驗。</p>
<h3><a href="#一小步，一大步" name="一小步，一大步">一小步，一大步</a></h3>
<p>讓我們嘗試一些更加複雜的東西。我們擁有的問題基本上是：</p>
<ol>
<li>每次更新將遊戲時間推動一個固定量。</li>
<li>這消耗一定量的<em>真實</em>時間來處理它。</li>
</ol>
<p>如果第二步消耗的時間超過第一步，遊戲就變慢了。
如果它需要超過16ms來推動遊戲時間16ms，那它永遠也跟不上。
但是如果一步中推動遊戲時間<em>超過</em>16ms，那我們可以減少更新頻率，就可以跟得上了。</p>
<p>接著的思路是基于上幀到現在有多少<em>真實</em>時間流逝來選擇前進的時間。
這一幀花費的時間越長，遊戲的間隔越大。
它總能跟上真實時間，因為它走的步子越來越大。
有人稱之為<em>變化的</em>或者<em>流動的</em>時間間隔。它看上去像是：</p>
<div class="codehilite"><pre><span></span><span class="kt">double</span> <span class="n">lastTime</span> <span class="o">=</span> <span class="n">getCurrentTime</span><span class="p">();</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">current</span> <span class="o">=</span> <span class="n">getCurrentTime</span><span class="p">();</span>
  <span class="kt">double</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">current</span> <span class="o">-</span> <span class="n">lastTime</span><span class="p">;</span>
  <span class="n">processInput</span><span class="p">();</span>
  <span class="n">update</span><span class="p">(</span><span class="n">elapsed</span><span class="p">);</span>
  <span class="n">render</span><span class="p">();</span>
  <span class="n">lastTime</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>每一幀，我們計算上次遊戲更新到現在有多少<em>真實</em>時間過去了（即變數<code>elapsed</code>）。
當我們更新遊戲狀態時將其傳入。
然後遊戲引擎讓遊戲世界推進一定的時間量。</p>
<p>假設有一顆子彈跨過屏幕。
使用固定的時間間隔，在每一幀中，你根據它的速度移動它。
使用變化的時間間隔，你<em>根據過去的時間拉伸速度</em>。
隨著時間間隔增加，子彈在每幀間移動的更遠。
無論是二十個快的小間隔還是四個慢的大間隔，子彈在<em>真實</em>時間裡移動<em>同樣</em>多的距離。
這看上去成功了：</p>
<ul>
<li>遊戲在不同的硬件上以固定的速度運行。</li>
<li>使用高端機器的玩家獲得了更流暢的遊戲體驗。</li>
</ul>
<p><span name="deterministic"></span></p>
<p>但是，悲劇，這裡有一個嚴重的問題：
遊戲不再是確定的了，也不再穩定。
這是我們給自己挖的一個坑：</p>
<aside name="deterministic">
<p>“確定的”代表每次你運行程序，如果給了它同樣的輸入，就獲得同樣的輸出。
可以想得到，在確定的程序中追蹤漏洞更容易——一旦找到造成漏洞的輸入，每次你都能重現之。</p>
<p>計算機本身是確定的；它們機械地執行程序。
在紛亂的真實世界加入時，非確定性出現了。
例如，網絡，系統時鐘，和線程調度都依賴于超出程序控制的外部世界。</p>
</aside>
<p>假設我們有個雙人聯網遊戲，Fred的遊戲機是台性能猛獸，而George正在使用他祖母的老爺機。
前面提到的子彈在他們的屏幕上飛行。
在Fred的機器上，遊戲跑的超級快，每個時間間隔都很小。
比如，我們塞了50幀在子彈穿過屏幕的那一秒。
可憐的George的機器只能塞進大約5幀。</p>
<p>這就意味著在Fred的機器上，物理引擎每秒更新50次位置，但是George的只更新5次。
大多數遊戲使用浮點數，它們有<em>舍入誤差</em>。
每次你將兩個浮點數加在一起，獲得的結果就會有點偏差。
Fred的機器做了10倍的操作，所以他的誤差要比George的更大。
<em>同樣</em> 的子彈最終在他們的機器上到了<em>不同的位置</em>。</p>
<p><span name="blowup"></span>
這是使用變化時間可引起的問題之一，還有更多問題呢。
為了實時運行，游戲物理引擎做的是實際機製法則的近似。
為了避免飛天遁地，物理引擎添加了阻尼。
這個阻尼運算被小心地安排成以固定的時間間隔運行。
改變了它，物理就不再穩定。</p>
<aside name="blowup">
<p>“飛天遁地”在這裡使用的是它的字面意思。當物理引擎卡住，對象獲得了完全錯誤的速度，就會飛到天上或者掉入地底。</p>
</aside>
<p>這種不穩定性太糟了，這個例子在這裡的唯一原因是作為警示寓言，引領我們到更好的東西……</p>
<h3><a href="#追逐時間" name="追逐時間">追逐時間</a></h3>
<p><span name="render"></span></p>
<p>遊戲中渲染通常<em>不會</em>被動態時間間隔影響到。
由於渲染引擎表現的是時間上的一瞬間，它不會計算上次到現在過了多久。
它只是將當前事物渲染在所在的地方。</p>
<aside name="render">
<p>這或多或少是成立的。像動態模糊的東西會被時間間隔影響，但如果有一點延遲，玩家通常也不會注意到。</p>
</aside>
<p>我們可以利用這點。
以固定的時間間隔<em>更新</em>遊戲，因為這讓所有事情變得簡單，物理和AI也更加穩定。
但是我們允許靈活調整<em>渲染</em>的時刻，釋放一些處理器時間。</p>
<p>它像這樣運作：自上一次遊戲循環過去了一定量的真實時間。
需要為遊戲的“當前時間”模擬推進相同長度的時間，以追上玩家的時間。
我們使用一<em>系列</em>的<em>固定</em>時間步長。
代碼大致如下：</p>
<div class="codehilite"><pre><span></span><span class="kt">double</span> <span class="n">previous</span> <span class="o">=</span> <span class="n">getCurrentTime</span><span class="p">();</span>
<span class="kt">double</span> <span class="n">lag</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">current</span> <span class="o">=</span> <span class="n">getCurrentTime</span><span class="p">();</span>
  <span class="kt">double</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">current</span> <span class="o">-</span> <span class="n">previous</span><span class="p">;</span>
  <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
  <span class="n">lag</span> <span class="o">+=</span> <span class="n">elapsed</span><span class="p">;</span>

  <span class="n">processInput</span><span class="p">();</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">lag</span> <span class="o">&gt;=</span> <span class="n">MS_PER_UPDATE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">update</span><span class="p">();</span>
    <span class="n">lag</span> <span class="o">-=</span> <span class="n">MS_PER_UPDATE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">render</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>這裡有幾個部分。
在每幀的開始，根據過去了多少真實的時間，更新<code>lag</code>。
這變數表明了遊戲世界時鐘比真實世界落後了多少，然後我們使用一個固定時間步長的內部循環進行追趕。
一旦我們追上真實時間，我們就渲染然後開始新一輪循環。
你可以將其畫成這樣：</p>
<p><img src="images/game-loop-fixed.png" alt="修改後的流程圖。處理輸入 &rarr; 更新遊戲 &rarr; 等待，然重回更新這步 &rarr; 渲染 &rarr; 回到開始。" /></p>
<p>注意這裡的時間步長不是<em>視覺上的</em>幀率了。
<code>MS_PER_UPDATE</code>只是我們更新遊戲的<em>間隔</em>。
這個間隔越短，就需要越多的處理次數來追上真實時間。
它越長，遊戲抖動的越厲害。
理想上，你想要它足夠短，通常快過60FPS，這樣遊戲在高速機器上會有高效的表現。</p>
<p><span name="bail"></span>
但是小心不要把它整得<em>太</em>短了。
你需要保證即使在最慢的機器上，這個時間步長也超過處理一次<code>update()</code>的時間。
否則，你的遊戲就跟不上現實時間了。</p>
<aside name="bail">
<p>我不會詳談這個，但你可以通過限定內層循環最大次數來保證這一點。
遊戲會變慢，但是比完全卡死要好。</p>
</aside>
<p>幸運的是，我們給自己了一些喘息的空間。
技巧在於我們將<em>渲染拉出了更新循環</em>。
這釋放了一大塊CPU時間。
最終結果是遊戲以固定時間步長<em>模擬</em>，該時間步長與硬件不相關。
只是使用低端硬件的玩家<em>看到的</em>會有抖動。</p>
<h3><a href="#卡在中間" name="卡在中間">卡在中間</a></h3>
<p>我們還剩一個問題，就是剩下的延遲。
以固定的時間步長更新遊戲，在任意時刻渲染。
這就意味著從玩家的角度看，遊戲經常在兩次更新之間時顯示。</p>
<p>這是時間線：</p>
<p><img src="images/game-loop-timeline.png" alt="一條時間線，上面是均勻分佈的更新時刻和不均勻的渲染時刻。" /></p>
<p>就像你看到的那樣，我們以緊湊固定的時間步長進行更新。
同時，我們在任何可能的時候渲染。
它比更新發生的要少，而且也不穩定。
兩者都沒問題。糟糕的是，我們不總能在正確的時間點渲染。
看看第三次渲染時間。它發生在兩次更新之間。</p>
<p><img src="images/game-loop-timeline-close.png" alt="時間線的一部分，渲染髮生在兩次更新之間。" /></p>
<p>想象一顆子彈飛過屏幕。第一次更新時，它在左邊。
第二次更新將它移到了右邊。
這個遊戲在兩次更新之間的時間點渲染，所以玩家期望看到子彈在屏幕的中間。
而現在的實現中，它還在左邊。這意味著看上去移動發生了卡頓。</p>
<p>方便的是，我們<em>實際</em>知道渲染時距離兩次更新的時間：它被存儲在<code>lag</code>中。
我們在<code>lag</code>比更新時間間隔小時，而不是<code>lag</code>是<em>零</em>時，跳出循環進行渲染。
<code>lag</code>的剩餘量？那就是到下一幀的時間。</p>
<p>當我們要渲染時，我們將它傳入：</p>
<p><span name="normal"></span></p>
<div class="codehilite"><pre><span></span><span class="n">render</span><span class="p">(</span><span class="n">lag</span> <span class="o">/</span> <span class="n">MS_PER_UPDATE</span><span class="p">);</span>
</pre></div>


<aside name="normal">
<p>我們在這裡除以<code>MS_PER_UPDATE</code>來<em>歸一化</em>值。
不管更新的時間步長是多少，傳給<code>render()</code>的值總在0（恰巧在前一幀）到1.0（恰巧在下一幀）之間。
這樣，渲染引擎不必擔心幀率。它只需處理0到1的值。</p>
</aside>
<p>渲染器知道每個遊戲對象<em>以及它當前的速度</em>。
假設子彈在屏幕左邊20像素的地方，正在以400像素每幀的速度向右移動。
如果在兩幀正中渲染，我們會給<code>render()</code>傳0.5。
它繪製了半幀之前的圖形，在220像素，啊哈，平滑的移動。</p>
<p>當然，也許這種推斷是錯誤的。
在我們計算下一幀時，也許會發現子彈碰撞到另一障礙，或者減速，又或者別的什麼。
我們只是在上一幀位置和我們<em>認為的</em>下一幀位置之間插值。
但只有在完成物理和AI更新後，我們才能知道真正的位置。</p>
<p>所以推斷有猜測的成分，有時候結果是錯誤的。
但是，幸運的，這種修正通常不可感知。
最起碼，比你不使用推斷導致的卡頓更不明顯。</p>
<h2><a href="#設計決策" name="設計決策">設計決策</a></h2>
<p>雖然這章我講了很多，但是有更多的東西我沒講。
一旦你考慮顯示刷新頻率的同步，多線程，多GPU，真正的遊戲循環會變得更加複雜。
即使在高層，這裡還有一些問題你需要回答：</p>
<h3><a href="#擁有遊戲循環的是你，還是平台？" name="擁有遊戲循環的是你，還是平台？">擁有遊戲循環的是你，還是平台？</a></h3>
<p>這個選擇通常已經是平台決定的。
如果你在做瀏覽器中的遊戲，很可能你<em>不能</em>編寫自己的經典遊戲循環。
瀏覽器本身的事件驅動機制阻礙了這一點。
類似的，如果你使用現存的遊戲引擎，你很可能依賴于它的遊戲循環而不是自己寫一個。</p>
<ul>
<li>
<p><strong>使用平台的事件循環：</strong></p>
<ul>
<li>
<p><em>簡單</em>。你不必擔心編寫和優化自己的遊戲核心循環。</p>
</li>
<li>
<p><em>平台友好。</em>
你不必明確地給平台一段時間讓它處理它自己的事件，不必緩存事件，不必管理任何平台輸入模型和你的不匹配之處。</p>
</li>
<li>
<p><em>你失去了對時間的控制。</em>
平台會在它方便時調用代碼。
如果這不如你想要的那樣平滑或者頻繁，太糟了。
更糟的是，大多數應用的事件循環並未為遊戲設計，通常<em>是</em>又慢又卡頓。</p>
</li>
</ul>
</li>
<li>
<p><strong>使用遊戲引擎的循環：</strong></p>
<ul>
<li>
<p><em>不必自己編寫。</em>
編寫遊戲循環非常需要技巧。
由於是每幀都要執行的核心代碼，小小的漏洞或者性能問題就對遊戲有巨大的影響。
穩固的遊戲循環是使用現有引擎的原因之一。</p>
</li>
<li>
<p><em>不必自己編寫。</em>
當然，硬幣的另一面是，如果引擎無法滿足你<em>真正的</em>需求，你也沒法獲得控制權。</p>
</li>
</ul>
</li>
<li>
<p><strong>自己寫：</strong></p>
<ul>
<li>
<p><em>完全的控制。</em>
你可以做任何想做的事情。你可以為遊戲的需求訂製開發。</p>
</li>
<li>
<p><em>你需要與平台交互。</em>
應用框架和操作系統通常需要時間片去處理自己的事件和其他工作。
如果你擁有應用的核心循環，平台就沒有這些時間片了。
你得顯式定期檢查，保證框架沒有掛起或者混亂。</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#如何管理能量消耗？" name="如何管理能量消耗？">如何管理能量消耗？</a></h3>
<p>在五年前這還不是問題。
遊戲運行在插到插座上的機器上或者專用的手持設備上。
但是隨著智能手機，筆記本以及移動遊戲的發展，現在需要關注這個問題了。
畫面絢麗，但會耗乾三十分鐘前充的電，並將手機變成空間加熱器的遊戲，可不能讓人開心。</p>
<p>現在，你需要考慮的不僅僅是讓遊戲看上去很棒，同時也要儘可能少的使用CPU。
你需要設置一個性能的<em>上限</em>：完成一幀之內所需的工作後，讓CPU休眠。</p>
<ul>
<li>
<p><strong>儘可能快的運行：</strong></p>
<p>這是PC遊戲的常態（即使越來越多的人在筆記本上運行遊戲）。
遊戲循環永遠不會顯式告訴系統休眠。相反，空閒的循環被劃在提升FPS或者圖像顯示效果上了。</p>
<p>這會給你最好的遊戲體驗。
但是，也會儘可能多的使用電量。如果玩家在筆記型電腦上遊玩，他們就得到了一個很好的加熱器。</p>
</li>
<li>
<p><strong>固定幀率</strong></p>
<p>移動遊戲更加注意遊戲的體驗質量，而不是最大化圖像畫質。
很多這種遊戲都會設置最大幀率（通常是30或60FPS）。
如果遊戲循環在分配的時間片消耗完之前完成，剩餘的時間它會休眠。</p>
<p>這給了玩家“足夠好的”遊戲體驗，也讓電池輕鬆了一點。</p>
</li>
</ul>
<h3><a href="#你如何控制遊戲速度？" name="你如何控制遊戲速度？">你如何控制遊戲速度？</a></h3>
<p><span name="platform"></span></p>
<p>遊戲循環有兩個關鍵部分：不阻塞用戶輸入和自適應的幀時間步長。
輸入部分很直觀。關鍵在於你如何處理時間。
這裡有數不盡的遊戲可運行的平台，
每個遊戲都需要在其中一些平台上運行。
如何適應平台變化就是關鍵。</p>
<aside name="platform">
<p>創作遊戲看來是人類的天性，因為每當我們建構可以計算的機器，首先做的就是在上面編遊戲。
PDP-1是一個僅有4096字內存的2kHz機器，但是Steve Russell和他的朋友還是在上面創建了Spacewar!。</p>
</aside>
<ul>
<li>
<p><strong>固定時間步長，沒有同步：</strong></p>
<p>見我們第一個樣例中的代碼。你只需儘可能快地運行遊戲。</p>
<ul>
<li>
<p><em>簡單</em>。這是主要的（好吧，唯一的）好處。</p>
</li>
<li>
<p><em>遊戲速度直接受到硬件和遊戲複雜度影響。</em>
主要的缺點是，如果有所變化，會直接影響遊戲速度。遊戲速度與遊戲循環緊密相關。</p>
</li>
</ul>
</li>
<li>
<p><strong>固定時間步長，有同步：</strong></p>
<p>對複雜度控制的下一步是使用固定的時間間隔，但在循環的末尾增加同步點，保證遊戲不會運行得過快。</p>
<ul>
<li>
<p><em>還是很簡單。</em>
這比過于簡單不可行的例子只多了一行代碼。
在多數遊戲循環中，你可能<em>總</em>需要做一些同步。
你可能需要<a href="double-buffer.html">雙緩衝</a>圖形並將緩衝塊與更新顯示的頻率同步。</p>
</li>
<li>
<p><em>電量友好。</em>
這對移動遊戲至關重要。你不想消耗不必要的電量。
通過簡單的休眠幾個毫秒而不是試圖每幀塞入更多的處理，你節約了電量。</p>
</li>
<li>
<p><em>遊戲不會運行的太快。</em>
這解決了固定循環速度的一半問題。</p>
</li>
<li>
<p><em>遊戲可能運行的太慢。</em>
如果花了太多時間更新和渲染一幀，播放也會減緩。
因為這種方案沒有分離更新和渲染，它比更高級的方案更容易遇到這點。
沒法扔掉<em>渲染</em>幀來追上真實時間，遊戲本身會變慢。</p>
</li>
</ul>
</li>
<li>
<p><strong>動態時間步長：</strong></p>
<p>我把這個方案放在這裡作為問題的解決辦法之一，附加警告：大多數我認識的遊戲開發者反對它。
不過記住<em>為什麼</em>反對它是很有價值的。</p>
<ul>
<li>
<p><em>能適應並調整，避免運行得太快或者太慢。</em>
 如果遊戲不能追上真實時間，它用越來越長的時間步長更新，直到追上。</p>
</li>
<li>
<p><em>讓遊戲不確定而且不穩定。</em>
 這是真正的問題，當然。在物理和網絡部分使用動態時間步長會遇見更多的困難。</p>
</li>
</ul>
</li>
<li>
<p><strong>固定更新時間步長，動態渲染：</strong></p>
<p>在示例代碼中提到的最後一個選項是最複雜的，但是也是最有適應性的。
它以固定時間步長更新，但是如果需要趕上玩家的時間，可以扔掉一些<em>渲染</em>幀。</p>
<ul>
<li>
<p><em>能適應並調整，避免運行得太快或者太慢。</em>
只要能實時<em>更新</em>，遊戲狀態就不會落後於真實時間。如果玩家用高端機器，它會回以更平滑的遊戲體驗。</p>
</li>
<li>
<p><em>更複雜。</em>
主要負面問題是需要在實現中寫更多東西。
你需要將更新的時間步長調整的儘可能小來適應高端機，同時不至于在低端機上太慢。</p>
</li>
</ul>
</li>
</ul>
<h2><a href="#參見" name="參見">參見</a></h2>
<ul>
<li>
<p>關於遊戲循環的經典文章是Glenn Fiedler的&#8221;<a href="http://gafferongames.com/game-physics/fix-your-timestep/">Fix Your Timestep</a>&#8220;。如果沒有這篇文章，這章就不會是這個樣子。</p>
</li>
<li>
<p>Witters關於<a href="http://www.koonsolo.com/news/dewitters-gameloop/">game loops</a>的文章也值得閱讀。</p>
</li>
<li>
<p><a href="http://unity3d.com/">Unity</a>框架有一個複雜的遊戲循環，細節在<a href="http://docs.unity3d.com/Manual/ExecutionOrder.html">這裡</a>有詳盡的解釋。</p>
</li>
</ul>
<nav>
  <span class="prev">&larr; <a href="double-buffer.html">上一章</a></span>
  <span class="next"><a href="update-method.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
