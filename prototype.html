<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />

<title>原型模式 &middot; Design Patterns Revisited &middot; 遊戲設計模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<!--
delete the font style for english.
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
-->
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="observer.html">上一章</a></span>
  <span class="next"><a href="singleton.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
<h1>原型模式</h1>
<h1 class="book"><a href="/">遊戲設計模式</a><span class="section"><a href="design-patterns-revisited.html">Design Patterns Revisited</a></span></h1>
<p><span name="original"></span>
我第一次聽到“原型”這個詞是在<em>設計模式</em>中。
如今，似乎每個人都在用這個詞，但他們討論的實際不是<a href="http://en.wikipedia.org/wiki/Prototype_pattern" class="gof-pattern">設計模式</a>。
我們會討論他們所說的原型，也會討論術語“原型”的有趣之處，和其背後的理念。
但首先，讓我們重訪傳統的設計模式。</p>
<aside name="original">
<p>“傳統的”一詞可不是隨便用的。
<em>設計模式</em>引自<em>1963年</em> Ivan Sutherland的<a href="http://en.wikipedia.org/wiki/Sketchpad">Sketchpad</a>傳奇項目，那是這個模式首次出現。
當其他人在聽迪倫和甲殼蟲樂隊時，Sutherland正忙於，你知道的，發明CAD，交互圖形和麵向對象編程的基本概念。</p>
<p>看看這個<a href="http://www.youtube.com/watch?v=USyoT_Ha_bA">demo</a>，跪服吧。</p>
</aside>
<h2><a href="#原型設計模式" name="原型設計模式">原型設計模式</a></h2>
<p>假設我們要用《聖鎧傳說》的風格做款遊戲。
野獸和惡魔圍繞著英雄，爭著要吃他的血肉。
這些可怖的同行者通過“生產者”進入這片區域，每種敵人有不同的生產者。</p>
<p>在這個例子中，假設我們遊戲中每種怪物都有不同的類——<code>Ghost</code>，<code>Demon</code>，<code>Sorcerer</code>等等，像這樣：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Monster</span>
<span class="p">{</span>
  <span class="c1">// 代碼……</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Ghost</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Monster</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Demon</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Monster</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Sorcerer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Monster</span> <span class="p">{};</span>
</pre></div>


<p>生產者構造特定種類怪物的實例。
為了在遊戲中支持每種怪物，我們<em>可以</em>用一種暴力的實現方法，
讓每個怪物類都有生產者類，得到平行的類結構：</p>
<p><span name="inherits-arrow"></span></p>
<p><img src="images/prototype-hierarchies.png" alt="平行的類結構，惡靈，惡魔，巫師都繼承怪物。惡靈生產者。惡魔生產者，巫師生產者都繼承生產者。" /></p>
<aside name="inherits-arrow">
<p>我得翻出落滿灰塵的UML書來畫這個圖表。<img src="images/arrow-inherits.png" class="arrow" alt="一個UML箭頭" />代表“繼承”。</p>
</aside>
<p>實現後看起來像是這樣：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Spawner</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Spawner</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">spawnMonster</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">GhostSpawner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Spawner</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">spawnMonster</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Ghost</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DemonSpawner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Spawner</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">spawnMonster</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Demon</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 你知道思路了……</span>
</pre></div>


<p>除非你會根據代碼數量來獲得工資，
否則將這些焊在一起很明顯不是好方法。
眾多類，眾多引用，眾多冗餘，眾多副本，眾多重複自我……</p>
<p>原型模式提供了一個解決方案。
關鍵思路是<em>一個對象可以產出與它自己相近的對象。</em>
如果你有一個惡靈，你可以製造更多惡靈。
如果你有一個惡魔，你可以製造其他惡魔。
任何怪物都可以被視為<em>原型</em>怪物，產出其他版本的自己。</p>
<p>為了實現這個功能，我們給基類<code>Monster</code>一個抽象方法<code>clone()</code>：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Monster</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Monster</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 其他代碼……</span>
<span class="p">};</span>
</pre></div>


<p>每個怪獸子類提供一個特定實現，返回與它自己的類和狀態都完全一樣的新對象。舉個例子：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Ghost</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Monster</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Ghost</span><span class="p">(</span><span class="kt">int</span> <span class="n">health</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">health_</span><span class="p">(</span><span class="n">health</span><span class="p">),</span>
    <span class="n">speed_</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Ghost</span><span class="p">(</span><span class="n">health_</span><span class="p">,</span> <span class="n">speed_</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">health_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">speed_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>一旦我們所有的怪物都支持這個，
我們不再需要為每個怪物類創建生產者類。我們只需定義一個類：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Spawner</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Spawner</span><span class="p">(</span><span class="n">Monster</span><span class="o">*</span> <span class="n">prototype</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">prototype_</span><span class="p">(</span><span class="n">prototype</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="n">Monster</span><span class="o">*</span> <span class="n">spawnMonster</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">prototype_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Monster</span><span class="o">*</span> <span class="n">prototype_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>它內部存有一個怪物，一個隱藏的怪物，
它唯一的任務就是被生產者當做模板，去產生更多一樣的怪物，
有點像一個從來不離開巢穴的蜂后。</p>
<p><img src="images/prototype-spawner.png" alt="一個生產者包含一個對怪物應用的原型欄位。
他調用原型的clone()方法來產生新的怪物。" /></p>
<p>為了得到惡靈生產者，我們創建一個惡靈的原型實例，然後創建擁有這個實例的生產者：</p>
<div class="codehilite"><pre><span></span><span class="n">Monster</span><span class="o">*</span> <span class="n">ghostPrototype</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ghost</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">Spawner</span><span class="o">*</span> <span class="n">ghostSpawner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Spawner</span><span class="p">(</span><span class="n">ghostPrototype</span><span class="p">);</span>
</pre></div>


<p>這個模式的靈巧之處在於它不但拷貝原型的<em>類</em>，也拷貝它的<em>狀態</em>。
這就意味著我們可以創建一個生產者，生產快速鬼魂，虛弱鬼魂，慢速鬼魂，而只需創建一個合適的原型鬼魂。</p>
<p>我在這個模式中找到了一些既優雅又令人驚嘆的東西。
我無法想象自己是如何創造出它們的，但我更無法想象<em>不知道</em>這些東西的自己該如何是好。</p>
<h3><a href="#效果如何？" name="效果如何？">效果如何？</a></h3>
<p>好吧，我們不需要為每個怪物創建單獨的生產者類，那很好。
但我們<em>確實</em>需要在每個怪物類中實現<code>clone()</code>。
這和使用生產者方法比起來也沒節約多少代碼量。</p>
<p>當你坐下來試著寫一個正確的<code>clone()</code>，會遇見令人不快的語義漏洞。
做深層拷貝還是淺層拷貝呢？換言之，如果惡魔拿著叉子，克隆惡魔也要克隆叉子嗎？</p>
<p>同時，這看上去沒減少已存問題上的代碼，
事實上還增添了些<em>人為的問題</em>。
我們需要將每個怪物有獨立的類作為前提條件。
這絕對<em>不是</em>當今大多數遊戲引擎運作的方法。</p>
<p>我們中大部分痛苦地學到，這樣龐雜的類層次管理起來很痛苦，
那就是我們為什麼用<a href="component.html" class="pattern">組件模式</a>和<a href="type-object.html" class="pattern">類型對象</a>為不同的實體建模，這樣無需一一建構自己的類。</p>
<h3><a href="#生產函數" name="生產函數">生產函數</a></h3>
<p>哪怕我們確實需要為每個怪物構建不同的類，這裡還有其他的實現方法。
不是使用為每個怪物建立分離的生產者<em>類</em>，我們可以創建生產<em>函數</em>，就像這樣：</p>
<div class="codehilite"><pre><span></span><span class="n">Monster</span><span class="o">*</span> <span class="nf">spawnGhost</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Ghost</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>這比構建怪獸生產者類更簡潔。生產者類只需簡單地存儲一個函數指針：</p>
<div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="n">Monster</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">SpawnCallback</span><span class="p">)();</span>

<span class="k">class</span> <span class="nc">Spawner</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Spawner</span><span class="p">(</span><span class="n">SpawnCallback</span> <span class="n">spawn</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">spawn_</span><span class="p">(</span><span class="n">spawn</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="n">Monster</span><span class="o">*</span> <span class="n">spawnMonster</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">spawn_</span><span class="p">();</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">SpawnCallback</span> <span class="n">spawn_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>為了給惡靈構建生產者，你需要做：</p>
<div class="codehilite"><pre><span></span><span class="n">Spawner</span><span class="o">*</span> <span class="n">ghostSpawner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Spawner</span><span class="p">(</span><span class="n">spawnGhost</span><span class="p">);</span>
</pre></div>


<h3><a href="#模板" name="模板">模板</a></h3>
<p><span name="templates"></span></p>
<p>如今，大多數C++開發者已然熟悉模板了。
生產者類需要為某類怪物構建實例，但是我們不想硬編碼是哪類怪物。
自然的解決方案是將它作為模板中的<em>類型參數</em>：</p>
<aside name="templates">
<p>我不太確定程序員是學著喜歡C++模板還是完全畏懼並遠離了C++。
不管怎樣，今日我見到的程序員中，使用C++的也都會使用模板。</p>
<p>這裡的<code>Spawner</code>類不必考慮將生產什麼樣的怪物，
它總與指向<code>Monster</code>的指針打交道。</p>
<p>如果我們只有<code>SpawnerFor&lt;T&gt;</code>類，模板類型沒有辦法共享父模板，
這樣的話，如果一段代碼需要與產生多種怪物類型的生產者打交道，就都得接受模板參數。</p>
</aside>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Spawner</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Spawner</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">spawnMonster</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SpawnerFor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Spawner</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">spawnMonster</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>像這樣使用它：</p>
<div class="codehilite"><pre><span></span><span class="n">Spawner</span><span class="o">*</span> <span class="n">ghostSpawner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SpawnerFor</span><span class="o">&lt;</span><span class="n">Ghost</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>


<h3><a href="#第一公民類型" name="第一公民類型">第一公民類型</a></h3>
<p><span name="type-obj"></span>
前面的兩個解決方案使用類完成了需求，<code>Spawner</code>使用類型進行參數化。
在C++中，類型不是第一公民，所以需要一些改動。
如果你使用JavaScript，Python，或者Ruby這樣的動態類型語言，
它們的類<em>是</em>可以傳遞的對象，你可以用更直接的辦法解決這個問題。</p>
<aside name="type-obj">
<p>某種程度上， <a href="type-object.html" class="pattern">類型對象</a>也是為了彌補第一公民類型的缺失。
但那個模式在擁有第一公民類型的語言中也有用，因為它讓<em>你</em>決定什麼是“類型”。
你也許想要與語言內建的類不同的語義。</p>
</aside>
<p>當你完成一個生產者，直接向它傳遞要構建的怪物類——那個代表了怪物類的運行時對象。超容易的，對吧。</p>
<p>綜上所述，老實說，我不能說找到了一種情景，而在這個情景下，原型<em>設計模式</em>是最好的方案。
也許你的體驗有所不同，但現在把它擱到一邊，我們討論點別的：將原型作為一種<em>語言範式</em>。</p>
<h2><a href="#原型語言範式" name="原型語言範式">原型語言範式</a></h2>
<p>很多人認為“面向對象編程”和“類”是同義詞。
OOP的定義卻讓人感覺正好相反，
毫無疑問，<em>OOP讓你定義“對象”，將數據和代碼綁定在一起。</em>
與C這樣的結構化語言相比，與Scheme這樣的函數語言相比，
OOP的特性是它將狀態和行為緊緊地綁在一起。</p>
<p>你也許認為類是完成這個的唯一方式方法，
但是包括Dave Ungar和Randall Smith的一大堆傢伙一直在拚命區分OOP和類。
他們在80年代創建了一種叫做Self的語言。它不用類實現了OOP。</p>
<h3><a href="#self語言" name="self語言">Self語言</a></h3>
<p>就單純意義而言，Self比基于類的語言<em>更加</em>面向對象。
我們認為OOP將狀態和行為綁在一起，但是基于類的語言實際將狀態和行為割裂開來。</p>
<p>拿你最喜歡的基于類的語言的語法來說。
為了接觸對象中的一些狀態，你需要在實例的內存中查詢。狀態<em>包含</em>在實例中。</p>
<p><span name="vtable"></span>
但是，為了調用方法，你需要找到實例的類，
然後在<em>那裡</em>調用方法。行為包含在<em>類</em>中。
獲得方法總需要通過中間層，這意味著欄位和方法是不同的。</p>
<p><img src="images/prototype-class.png" alt="一個類，包含了一系列方法。一個實例，包含了一系列欄位和指向類的指針。" /></p>
<aside name="vtable">
<p>舉個例子，為了調用C++中的虛方法，你需要在實例中找指向虛方法表的指針，然後再在那裡找方法。</p>
</aside>
<p>Self結束了這種分歧。<em>無論你要找啥</em>，都只需在對象中找。
實例同時包含狀態和行為。你可以構建擁有完全獨特方法的對象。</p>
<p><span name="island"></span></p>
<p><img src="images/prototype-object.png" alt="一個對象中同時包含了欄位和方法。" /></p>
<aside name="island">
<p>沒有人能與世隔絕，但這個對象是。</p>
</aside>
<p>如果這就是Self語言的全部，那它將很難使用。
基于類的語言中的繼承，不管有多少缺陷，給了有用的機制來重用代碼，避免重複。
為了不使用類而實現一些類似的功能，Self語言加入了<em>委託</em>。</p>
<p><span name="parent"></span>
如果要在對象中尋找欄位或者調用方法，首先在對象內部查找。
如果能找到，那就成了。如果找不到，在對象的<em>父對象</em>中尋找。
這裡的父類僅僅是一個對其他對象的引用。
當我們沒能在第一個對象中找到屬性，我們嘗試它的父對象，然後父類的父對象，繼續下去直到找到或者沒有父對象為止。
換言之，失敗的查找被<em>委託</em>給對象的父對象。</p>
<aside name="parent">
<p>我在這裡簡化了。Self實際上支持多個父對象。
父對象只是特別標明的欄位，意味著你可以繼承它們或者在運行時改變他們，
你最終得到了“動態繼承”。</p>
</aside>
<p><img src="images/prototype-delegate.png" alt="一個對象包含了欄位和方法，以及一個指向委託對象的指針。" /></p>
<p>父對象讓我們在不同對象間重用行為（還有狀態！），這樣就完成了類的公用功能。
類做的另一個關鍵事情就是給出了創建實例的方法。
當你需要新的某物，你可以直接<code>new Thingamabob()</code>，或者隨便什麼你喜歡的表達法。
類是實例的生產工廠。</p>
<p>不用類，我們怎樣創建新的實例？
特別的，我們如何創建一堆有共同點的新東西？
就像這個設計模式，在Self中，達到這點的方式是使用<em>克隆</em>。</p>
<p>在Self語言中，就好像<em>每個</em>對象都自動支持原型設計模式。
任何對象都能被克隆。為了獲得一堆相似的對象，你：</p>
<ol>
<li>將對象塑造成你想要的狀態。你可以直接克隆系統內建的基本<code>Object</code>，然後向其中添加欄位和方法。</li>
<li>克隆它來產出……額……隨你想要多少就克隆多少個對象。</li>
</ol>
<p>無需煩擾自己實現<code>clone()</code>；我們就實現了優雅的原型模式，原型被內建在系統中。</p>
<p><span name="finch"></span>
這個系統美妙，靈巧，而且小巧，
一聽說它，我就開始創建一個基于原型的語言來進一步學習。</p>
<aside name="finch">
<p>我知道從頭開始構建一種編程語言語言不是學習它最有效率的辦法，但我能說什麼呢？我可算是個怪人。
如果你很好奇，我構建的語言叫<a href="http://finch.stuffwithstuff.com/">Finch</a>.</p>
</aside>
<h3><a href="#它的實際效果如何？" name="它的實際效果如何？">它的實際效果如何？</a></h3>
<p><span name="no-fun"></span>
能使用純粹基于原型的語言讓我很興奮，但是當我真正上手時，
我發現了一個令人不快的事實：用它編程沒那麼有趣。</p>
<aside name="no-fun">
<p>從小道消息中，我聽說很多Self程序員得出了相同的結論。
但這項目並不是一無是處。
Self非常的靈活，為此創造了很多虛擬機的機制來保持高速運行。</p>
<p>他們發明了JIT編譯，垃圾回收，以及優化方法分配——這都是由同一批人實現的——
這些新玩意讓動態類型語言能快速運行，構建了很多大受歡迎的應用。</p>
</aside>
<p>是的，語言本身很容易實現，那是因為它把複雜度甩給了用戶。
一旦開始試著使用這語言，我發現我想念基于類語言中的層次結構。
最終，在構建語言缺失的庫概念時，我放棄了。</p>
<p>鑒於我之前的經驗都來自基于類的語言，因此我的頭腦可能已經固定在它的範式上了。
但是直覺上，我認為大部分人還是喜歡有清晰定義的“事物”。</p>
<p>除去基于類語言自身的成功以外，看看有多少遊戲用類建模描述玩家角色，以及不同的敵人、物品、技能。
不是遊戲中的每個怪物都與眾不同，你不會看到“洞穴人和哥布林還有雪混合在一起”這樣的怪物。</p>
<p><span name="telling"></span>
原型是非常酷的範式，我希望有更多人瞭解它，
但我很慶幸不必天天用它編程。
完全皈依原型的代碼是一團漿糊，難以閱讀和使用。</p>
<aside name="telling">
<p>這同時證明，<em>很少</em> 有人使用原型風格的代碼。我查過了。</p>
</aside>
<h3><a href="#javascript又怎麼樣呢？" name="javascript又怎麼樣呢？">JavaScript又怎麼樣呢？</a></h3>
<p>好吧，如果基于原型的語言不那麼友好，怎麼解釋JavaScript呢？
這是一個有原型的語言，每天被數百萬人使用。運行JavaScript的機器數量超過了地球上其他所有的語言。</p>
<p><span name="ten"></span>Brendan Eich，JavaScript的締造者，
從Self語言中直接汲取靈感，很多JavaScript的語義都是基于原型的。
每個對象都有屬性的集合，包含欄位和“方法”（事實上只是存儲為欄位的函數）。
A對象可以擁有B對象，B對象被稱為A對象的“原型”，
如果A對象的欄位獲取失敗就會委託給B對象。</p>
<aside name="ten">
<p>作為語言設計者，原型的誘人之處是它們比類更易於實現。
Eich充分利用了這一點，他在十天內創建了JavaScript的第一個版本。</p>
</aside>
<p>但除那以外，我相信在實踐中，JavaScript更像是基于類的而不是基于原型的語言。
一個要點是JavaScript移除了一些基</p>
<p>在JavaScript中沒有方法來克隆一個對象。
最接近的方法是<code>Object.create()</code>，允許你創建新對象作為現有對象的委託。
這個方法在ECMAScript5中才添加，而那已是JavaScript出現後的十四年了。
相對於克隆，讓我帶你參觀一下JavaScript中定義類和創建對象的經典方法。
我們從<em>構造器函數</em>開始：</p>
<div class="codehilite"><pre><span></span><span class="kd">function</span> <span class="nx">Weapon</span><span class="p">(</span><span class="nx">range</span><span class="p">,</span> <span class="nx">damage</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">range</span> <span class="o">=</span> <span class="nx">range</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">damage</span> <span class="o">=</span> <span class="nx">damage</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>這創建了一個新對象，初始化了它的欄位。你像這樣引入它：</p>
<div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nx">sword</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Weapon</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</pre></div>


<p>這裡的<code>new</code>調用<code>Weapon()</code>函數，而<code>this</code>綁定在新的空對象上。
函數為新對象添加了一系列欄位，然後返回填滿的對象。</p>
<p><code>new</code>也為你做了另外一件事。
當它創建那個新的空對象時，它將空對象的委託和一個原型對象連接起來。
你可以用<code>Weapon.prototype</code>來獲得原型對象。</p>
<p>在構造器中添加屬性，而通常向原型對象添加方法來定義<em>行為</em>。就像這樣：</p>
<div class="codehilite"><pre><span></span><span class="nx">Weapon</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">attack</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">distanceTo</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">range</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Out of range!&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">target</span><span class="p">.</span><span class="nx">health</span> <span class="o">-=</span> <span class="k">this</span><span class="p">.</span><span class="nx">damage</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>這給武器原型添加了<code>attack</code>屬性，其值是一個函數。
由於<code>new Weapon()</code>返回的每一個對象都有給<code>Weapon.prototype</code>的委託，
你現在可以調用<code>sword.attack()</code>，這樣調用那個函數。
看上去像是這樣：</p>
<p><img src="images/prototype-weapon.png" alt="一個武器原型包含一個 attack() 方法和其他方法。一個寶劍對象包含一個指向武器的委託和其他欄位。" /></p>
<p>讓我們複習一下：</p>
<ul>
<li>通過“new”操作創建對象，該操作引入代表類型的對象——構造器函數。</li>
<li>狀態存儲在實例中。</li>
<li>行為通過間接層——原型的委託——被存儲在獨立的對象中，代表了一系列特定類型對象的共享方法。</li>
</ul>
<p>說我瘋了吧，但這聽起來很像是我之前描述的類。
你<em>可以</em>在JavaScript中寫原型風格的代碼（<em>不用</em> 克隆），
但是就語法和慣用法更推薦基于類的實現。</p>
<p><span name="good"></span>
個人而言，我認為這是好事。
就像我說的，我發現一切都使用原型，那麼很難編寫代碼，
所以我喜歡JavaScript，它將整個核心語義包上了一層糖衣。</p>
<h2><a href="#為數據模型構建原型" name="為數據模型構建原型">為數據模型構建原型</a></h2>
<p>好吧，我之前不斷的討論我<em>不喜歡</em>原型的原因，這讓這一章讀起來令人沮喪。
我認為這本書該更歡樂些，所以在最後，讓我們討論討論原型<em>確實</em>有用，或者更加精確，<em>委託</em> 有用的地方。</p>
<p>隨著編程的進行，如果你比較程序與數據的位元組數，
那麼你會發現數據的占比穩定地增長。
早期的遊戲在程序中生成几乎所有東西，這樣程序可以塞進磁碟和老式遊戲卡帶。
在今日的遊戲中，代碼只是驅動遊戲的“引擎”，遊戲是完全由數據定義的。</p>
<p>這很好，但是將內容推到數據檔案中並不能魔術般解決組織大項目的挑戰。
它只能把這挑戰變得更難。
我們使用編程語言就因為它們有辦法管理複雜性。</p>
<p>不再是將一堆代碼拷來拷去，我們將其移入函數中，通過名字調用。
不再是在一堆類之間複製方法，我們將其放入單獨的類中，讓其他類可以繼承或者組合。</p>
<p>當遊戲數據達到一定規模時，你真的需要考慮一些相似的方案。
我不指望在這裡能說清數據模式這個問題，
但我確實希望提出個思路，讓你在遊戲中考慮考慮：使用原型和委託來重用數據。</p>
<p><span name="shameless"></span>
假設我們為早先提到的山寨版《聖鎧傳說》定義數據模型。
遊戲設計者需要在很多檔案中設定怪物和物品的屬性。</p>
<aside name="shameless">
<p>這標題是我原創的，沒有受到任何已存的多人地下城遊戲的影響。
請不要起訴我。</p>
</aside>
<p><span name="inventing"></span>
一個常用的方法是使用JSON。
數據實體一般是<em>字典</em>，或者<em>屬性集合</em>，或者其他什麼術語，
因為程序員就喜歡為舊事物發明新名字。</p>
<aside name="inventing">
<p>我們重新發明了太多次，Steve Yegge稱之為<a href="http://steve-yegge.blogspot.com/2008/10/universal-design-pattern.html">&#8220;通用設計模式&#8221;</a>.</p>
</aside>
<p>所以遊戲中的哥布林也許被定義為像這樣的東西：</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin grunt&quot;</span><span class="p">,</span>
  <span class="nt">&quot;minHealth&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="nt">&quot;maxHealth&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nt">&quot;resists&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cold&quot;</span><span class="p">,</span> <span class="s2">&quot;poison&quot;</span><span class="p">],</span>
  <span class="nt">&quot;weaknesses&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire&quot;</span><span class="p">,</span> <span class="s2">&quot;light&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>


<p>這看上去很易懂，哪怕是最討厭文本的設計者也能使用它。
所以，你可以給哥布林大家族添加幾個兄弟分支：</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin wizard&quot;</span><span class="p">,</span>
  <span class="nt">&quot;minHealth&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="nt">&quot;maxHealth&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nt">&quot;resists&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cold&quot;</span><span class="p">,</span> <span class="s2">&quot;poison&quot;</span><span class="p">],</span>
  <span class="nt">&quot;weaknesses&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire&quot;</span><span class="p">,</span> <span class="s2">&quot;light&quot;</span><span class="p">],</span>
  <span class="nt">&quot;spells&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire ball&quot;</span><span class="p">,</span> <span class="s2">&quot;lightning bolt&quot;</span><span class="p">]</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin archer&quot;</span><span class="p">,</span>
  <span class="nt">&quot;minHealth&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="nt">&quot;maxHealth&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nt">&quot;resists&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cold&quot;</span><span class="p">,</span> <span class="s2">&quot;poison&quot;</span><span class="p">],</span>
  <span class="nt">&quot;weaknesses&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire&quot;</span><span class="p">,</span> <span class="s2">&quot;light&quot;</span><span class="p">],</span>
  <span class="nt">&quot;attacks&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;short bow&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>


<p>現在，如果這是代碼，我們會聞到了臭味。
在實體間有很多的重複，訓練優良的程序員<em>討厭</em>重複。
它浪費了空間，消耗了作者更多時間。
你需要仔細閱讀代碼才知道這些數據<em>是不是</em>相同的。
這難以維護。
如果我們決定讓所有哥布林變強，需要記得將三個哥布林都更新一遍。糟糕糟糕糟糕。</p>
<p>如果這是代碼，我們會為“哥布林”構建抽象，並在三個哥布林類型中重用。
但是無能的JSON沒法這麼做。所以讓我們把它做得更加巧妙些。</p>
<p><span name="meta"></span></p>
<p>我們可以為對象添加<code>"prototype"</code>欄位，記錄委託對象的名字。
如果在此對象內沒找到一個欄位，那去委託對象中查找。</p>
<aside name="meta">
<p>這讓<code>"prototype"</code>不再是數據，成為了<em>元</em>數據。
哥布林有綠色疣皮和黃色牙齒。
它們沒有原型。
原型是<em>表示哥布林的數據模型</em>的屬性，而不是哥布林本身的屬性。</p>
</aside>
<p>這樣，我們可以簡化我們的哥布林JSON內容：</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin grunt&quot;</span><span class="p">,</span>
  <span class="nt">&quot;minHealth&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="nt">&quot;maxHealth&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nt">&quot;resists&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cold&quot;</span><span class="p">,</span> <span class="s2">&quot;poison&quot;</span><span class="p">],</span>
  <span class="nt">&quot;weaknesses&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire&quot;</span><span class="p">,</span> <span class="s2">&quot;light&quot;</span><span class="p">]</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin wizard&quot;</span><span class="p">,</span>
  <span class="nt">&quot;prototype&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin grunt&quot;</span><span class="p">,</span>
  <span class="nt">&quot;spells&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire ball&quot;</span><span class="p">,</span> <span class="s2">&quot;lightning bolt&quot;</span><span class="p">]</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin archer&quot;</span><span class="p">,</span>
  <span class="nt">&quot;prototype&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin grunt&quot;</span><span class="p">,</span>
  <span class="nt">&quot;attacks&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;short bow&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>


<p>由於弓箭手和術士都將grunt作為原型，我們就不需要在它們中重複血量，防禦和弱點。
我們為數據模型增加的邏輯超級簡單——基本的單一委託——但已經成功擺脫了一堆冗餘。</p>
<p>有趣的事情是，我們沒有更進一步，把哥布林委託的<em>抽象</em>原型設置成“基本哥布林”。
相反，我們選擇了最簡單的哥布林，然後委託給它。</p>
<p>在基于原型的系統中，對象可以克隆產生新對象是很自然的，
我認為在這裡也一樣自然。這特別適合記錄那些只有一處不同的實體的數據。</p>
<p>想想Boss和其他獨特的事物，它們通常是更加常見事物的重新定義，
原型委託是定義它們的好方法。
斷頭魔劍，就是一把擁有加成的長劍，可以像下面這樣表示：</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sword of Head-Detaching&quot;</span><span class="p">,</span>
  <span class="nt">&quot;prototype&quot;</span><span class="p">:</span> <span class="s2">&quot;longsword&quot;</span><span class="p">,</span>
  <span class="nt">&quot;damageBonus&quot;</span><span class="p">:</span> <span class="s2">&quot;20&quot;</span>
<span class="p">}</span>
</pre></div>


<p>只需在遊戲引擎上多花點時間，你就能讓設計者更加方便地添加不同的武器和怪物，而增加的這些豐富度能夠取悅玩家。</p>
<nav>
  <span class="prev">&larr; <a href="observer.html">上一章</a></span>
  <span class="next"><a href="singleton.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
