<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />

<title>命令模式 &middot; Design Patterns Revisited &middot; 遊戲設計模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<!--
delete the font style for english.
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
-->
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="design-patterns-revisited.html">上一章</a></span>
  <span class="next"><a href="flyweight.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
<h1>命令模式</h1>
<h1 class="book"><a href="/">遊戲設計模式</a><span class="section"><a href="design-patterns-revisited.html">Design Patterns Revisited</a></span></h1>
<p>命令模式是我最喜歡的模式之一。
大多數我寫的大型程序，遊戲或者別的什麼，都會在某處用到它。
當在正確的地方使用時，它可以將複雜的代碼清理乾淨。
對於這樣一個了不起的模式，不出所料，GoF有個深奧的定義：</p>
<blockquote>
<p>將一個請求封裝為一個對象，從而使你可用不同的請求對客戶進行參數化；
對請求排隊或記錄請求日誌，以及支持可撤銷的操作。</p>
</blockquote>
<p>我想你也會覺得這個句子晦澀難懂。
第一，它的比喻難以理解。
在軟件之外的狂野世界，詞語可以指代任何事物，“客戶”是一個<em>人</em>——那些和你做生意的人。
據我查證，人類不能被“參數化”。</p>
<p>然後，句子餘下的部分介紹了可能會使用這個模式的場景。
如果你的場景不在這個列表中，那麼這對你就沒什麼用處。
<em>我的</em>命令模式精簡定義為：</p>
<p><span name="latin"></span>
<strong>命令是<em>具現化的方法調用</em>。</strong></p>
<aside name="latin">
<p>“Reify（具現化）”來自于拉丁語“res”，意為“thing”（事物），加上英語尾碼“&ndash;fy”。
所以它意為“thingify”，沒準用“thingify”更合適。</p>
</aside>
<p>當然，“精簡”往往意味著著“缺少必要信息”，所以這可能沒有太大的改善。
讓我擴展一下。“具現化”，如果你沒有聽說過的話，它的意思是“實例化，對象化”。
另外一種具現化的解釋方式是將某事物作為“第一公民”對待。</p>
<aside name="reflection">
<p>在某些語言中的<em>反射</em>允許你在程序運行時命令式地和類型交互。
你可以獲得類的類型對象，可以與其交互看看這個類型能做什麼。換言之，反射是<em>具現化類型的系統</em>。</p>
</aside>
<p><span name="reflection"></span>兩種術語都意味著將<em>概念</em>變成<em>數據</em>
——一個對象——可以存儲在變數中，傳給函數。
所以稱命令模式為“具現化方法調用”，意思是方法調用被存儲在對象中。</p>
<p>這聽起來有些像“回調”，“第一公民函數”，“函數指針”，“閉包”，“偏函數”，
取決於你在學哪種語言，事實上大致上是同一個東西。GoF隨後說：</p>
<blockquote>
<p>命令模式是一種回調的面向對象實現。</p>
</blockquote>
<p>這是一種對命令模式更好的解釋。</p>
<p>但這些都既抽象又模糊。我喜歡用實際的東西作為章節的開始，不好意思，搞砸了。
作為彌補，從這裡開始都是命令模式能出色應用的例子。</p>
<h2><a href="#配置輸入" name="配置輸入">配置輸入</a></h2>
<p>在每個遊戲中都有一塊代碼讀取用戶的輸入——按鈕按下，鍵盤敲擊，滑鼠點擊，諸如此類。
這塊代碼會獲取用戶的輸入，然後將其變為遊戲中有意義的行為：</p>
<p><img src="images/command-buttons-one.png" alt="一個手柄, A鍵調用swapWeapon()，B鍵調用lurch()，X鍵調用jump()，Y鍵調用fireGun()。" /></p>
<p>下面是一種簡單的實現：</p>
<p><span name="lurch"></span></p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">InputHandler</span><span class="o">::</span><span class="n">handleInput</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_X</span><span class="p">))</span> <span class="n">jump</span><span class="p">();</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_Y</span><span class="p">))</span> <span class="n">fireGun</span><span class="p">();</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_A</span><span class="p">))</span> <span class="n">swapWeapon</span><span class="p">();</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_B</span><span class="p">))</span> <span class="n">lurchIneffectively</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<aside name="lurch">
<p>專家建議：不要太經常地按B。</p>
</aside>
<p>這個函數通常在<a class="pattern" href="game-loop.html">遊戲循環</a>中每幀調用一次，我確信你可以理解它做了什麼。
在我們想將用戶的輸入和程序行為硬編碼在一起時，這段代碼可以正常工作，但是許多遊戲允許玩家<em>配置</em>按鍵的功能。</p>
<p>為了支持這點，需要將這些對<code>jump()</code>和<code>fireGun()</code>的直接調用轉化為可以變換的東西。
“變換”聽起來有點像變數干的事，因此我們需要表示遊戲行為的<em>對象</em>。進入：命令模式。</p>
<p>我們定義了一個基類代表可觸發的遊戲行為：</p>
<p><span name="one-method"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Command</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Command</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<aside name="one-method">
<p>當你有介面只包含一個沒有返回值的方法時，很可能你可以使用命令模式。</p>
</aside>
<p>然後我們為不同的遊戲行為定義相應的子類：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">JumpCommand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Command</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span> <span class="n">jump</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FireCommand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Command</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span> <span class="n">fireGun</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 你知道思路了吧</span>
</pre></div>


<p>在代碼的輸入處理部分，為每個按鍵存儲一個指向命令的指針。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">InputHandler</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">handleInput</span><span class="p">();</span>

  <span class="c1">// 綁定命令的方法……</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Command</span><span class="o">*</span> <span class="n">buttonX_</span><span class="p">;</span>
  <span class="n">Command</span><span class="o">*</span> <span class="n">buttonY_</span><span class="p">;</span>
  <span class="n">Command</span><span class="o">*</span> <span class="n">buttonA_</span><span class="p">;</span>
  <span class="n">Command</span><span class="o">*</span> <span class="n">buttonB_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>現在輸入處理部分這樣處理：</p>
<p><span name="null"></span></p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">InputHandler</span><span class="o">::</span><span class="n">handleInput</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_X</span><span class="p">))</span> <span class="n">buttonX_</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_Y</span><span class="p">))</span> <span class="n">buttonY_</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_A</span><span class="p">))</span> <span class="n">buttonA_</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_B</span><span class="p">))</span> <span class="n">buttonB_</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<aside name="null">
<p>注意在這裡沒有檢測<code>NULL</code>了嗎？這假設每個按鍵都與<em>某些</em>命令相連。</p>
<p>如果想支持不做任何事情的按鍵又不想顯式檢測<code>NULL</code>，我們可以定義一個命令類，它的<code>execute()</code>什麼也不做。
這樣，某些按鍵處理器不必設為<code>NULL</code>，只需指向這個類。這種模式被稱為<a href="http://en.wikipedia.org/wiki/Null_Object_pattern">空對象</a>。</p>
</aside>
<p>以前每個輸入直接調用函數，現在會有一層間接定址：</p>
<p><img src="images/command-buttons-two.png" alt="一個手柄，每個按鍵都與一個特定的'button_'變數相關聯，這個變數再與函數關聯。" /></p>
<p>這是命令模式的簡短介紹。如果你能夠看出它的好處，就把這章剩下的部分作為獎勵吧。</p>
<h2><a href="#角色說明" name="角色說明">角色說明</a></h2>
<p>我們剛纔定義的類可以在之前的例子上正常工作，但有很大的侷限。
問題在於假設頂層的<code>jump()</code>, <code>fireGun()</code>之類的函數可以找到玩家的角色，然後像操縱木偶一樣操縱它。</p>
<p>這些假定的耦合限制了這些命令的用處。<code>JumpCommand</code><em>只能</em> 讓玩家的角色跳躍。讓我們放鬆這個限制。
不讓函數去找它們控制的角色，我們將函數控制的角色對象<em>傳進去</em>：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Command</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Command</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">(</span><span class="n">GameActor</span><span class="o">&amp;</span> <span class="n">actor</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>這裡<code>GameActor</code>是代表遊戲世界中角色的“遊戲對象”類。
我們將其傳給<code>execute()</code>，這樣可以在命令的子類中添加函數，來與我們選擇的角色關聯，就像這樣：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">JumpCommand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Command</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">(</span><span class="n">GameActor</span><span class="o">&amp;</span> <span class="n">actor</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">actor</span><span class="p">.</span><span class="n">jump</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>現在，我們可以使用這個類讓遊戲中的任何角色跳來跳去了。
在輸入控制部分和在對象上調用命令部分之間，我們還缺了一塊代碼。
第一，我們修改<code>handleInput()</code>，讓它可以<em>返回</em>命令：</p>
<div class="codehilite"><pre><span></span><span class="n">Command</span><span class="o">*</span> <span class="n">InputHandler</span><span class="o">::</span><span class="n">handleInput</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_X</span><span class="p">))</span> <span class="k">return</span> <span class="n">buttonX_</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_Y</span><span class="p">))</span> <span class="k">return</span> <span class="n">buttonY_</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_A</span><span class="p">))</span> <span class="k">return</span> <span class="n">buttonA_</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_B</span><span class="p">))</span> <span class="k">return</span> <span class="n">buttonB_</span><span class="p">;</span>

  <span class="c1">// 沒有按下任何按鍵，就什麼也不做</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>這裡不能立即執行，因為還不知道哪個角色會傳進來。
這裡我們享受了命令是具體調用的好處——<code>延遲</code>到調用執行時再知道。</p>
<p>然後，需要一些接受命令的代碼，作用在玩家角色上。像這樣：</p>
<div class="codehilite"><pre><span></span><span class="n">Command</span><span class="o">*</span> <span class="n">command</span> <span class="o">=</span> <span class="n">inputHandler</span><span class="p">.</span><span class="n">handleInput</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">command</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">actor</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>將<code>actor</code>視為玩家角色的引用，它會正確的按著玩家的輸入移動，
所以我們賦予了角色和前面例子中相同的行為。
通過在命令和角色間增加了一層重定向，
我們獲得了一個靈巧的功能：<em>我們可以讓玩家控制遊戲中的任何角色，只需向命令傳入不同的角色。</em></p>
<p>在實踐中，這個特性並不經常使用，但是<em>經常</em>會有類似的用例跳出來。
到目前為止，我們只考慮了玩家控制的角色，但是遊戲中的其他角色呢？
它們被遊戲AI控制。我們可以在AI和角色之間使用相同的命令模式；AI代碼只需生成<code>Command</code>對象。</p>
<p>在選擇命令的AI和展現命令的遊戲角色間解耦給了我們很大的靈活度。
我們可以對不同的角色使用不同的AI，或者為了不同的行為而混合AI。
想要一個更加有攻擊性的同伴？插入一個更加有攻擊性的AI為其生成命令。
事實上，我們甚至可以為<em>玩家角色</em>加上AI，
這在原型階段，遊戲需要自動演示時是很有用的。</p>
<p><span name="queue"></span>把控制角色的命令變為第一公民對象，去除直接方法調用中嚴厲的束縛。
將其視為命令隊列，或者是命令流：</p>
<aside name="queue">
<p>隊列能為你做的更多事情，請看<a href="event-queue.html" class="pattern">事件隊列</a>。</p>
</aside>
<p><span name="stream"></span></p>
<p><img src="images/command-stream.png" alt="一條連接AI到角色的管道。" /></p>
<aside name="stream">
<p>為什麼我覺得需要為你畫一幅“流”的圖像？又是為什麼它看上去像是管道？</p>
</aside>
<p><span name="network"></span>一些代碼（輸入控製器或者AI）產生一系列命令放入流中。
另一些代碼（調度器或者角色自身）調用並消耗命令。
通過在中間加入隊列，我們解耦了消費者和生產者。</p>
<aside name="network">
<p>如果將這些指令<em>序列化</em>，我們可以通過網絡流傳輸它們。
我們可以接受玩家的輸入，將其通過網絡發送到另外一台機器上，然後重現之。這是網絡多人遊戲的基礎。</p>
</aside>
<h2><a href="#撤銷和重做" name="撤銷和重做">撤銷和重做</a></h2>
<p><span name="hate"></span>
最後的這個例子是這種模式最廣為人知的使用情況。
如果一個命令對象可以<em>做</em>一件事，那麼它亦可以<em>撤銷</em>這件事。
在一些策略遊戲中使用撤銷，這樣你就可以回滾那些你不喜歡的操作。
在人們<em>創造</em>遊戲時，這是<em>必不可少的</em>工具。
一個不能撤銷誤操作導致的錯誤的編輯器，肯定會讓遊戲設計師恨你。</p>
<aside name="hate">
<p>這是經驗之談。</p>
</aside>
<p>沒有了命令模式，實現撤銷非常困難，有了它，就是小菜一碟。
假設我們在製作單人回合制遊戲，想讓玩家能撤銷移動，這樣他們就可以集中注意力在策略上而不是猜測上。</p>
<p>我們已經使用了命令來抽象輸入控制，所以每個玩家的舉動都已經被封裝其中。
舉個例子，移動一個單位的代碼可能如下：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MoveUnitCommand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Command</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">MoveUnitCommand</span><span class="p">(</span><span class="n">Unit</span><span class="o">*</span> <span class="n">unit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">unit_</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span>
    <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
    <span class="n">y_</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">unit_</span><span class="o">-&gt;</span><span class="n">moveTo</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Unit</span><span class="o">*</span> <span class="n">unit_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>注意這和前面的命令有些許不同。
在前面的例子中，我們需要從修改的角色那裡<em>抽象</em>命令。
在這個例子中，我們將命令<em>綁定</em>到要移動的單位上。
這條命令的實例不是通用的“移動某物”命令；而是遊戲回合中特殊的一次移動。</p>
<p>這展現了命令模式應用時的一種情形。
在某些情形中，就像之前例子，指令是可重用的對象，代表了<em>可執行的事件</em>。
我們早期的輸入控製器將其實現為一個命令對象，然後在按鍵按下時調用其<code>execute()</code>方法。</p>
<p><span name="free"></span>這裡的命令更加特殊。它們代表了特定時間點能做的特定事件。
這意味著輸入控制代碼可以在玩家下決定時<em>創造</em>一個實例。就像這樣：</p>
<div class="codehilite"><pre><span></span><span class="n">Command</span><span class="o">*</span> <span class="nf">handleInput</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Unit</span><span class="o">*</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">getSelectedUnit</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_UP</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// 向上移動單位</span>
    <span class="kt">int</span> <span class="n">destY</span> <span class="o">=</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">MoveUnitCommand</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">(),</span> <span class="n">destY</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isPressed</span><span class="p">(</span><span class="n">BUTTON_DOWN</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// 向下移動單位</span>
    <span class="kt">int</span> <span class="n">destY</span> <span class="o">=</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">MoveUnitCommand</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">unit</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">(),</span> <span class="n">destY</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 其他的移動……</span>

  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<aside name="free">
<p>當然，在像C++這樣沒有垃圾回收的語言，這意味著執行命令的代碼也要負責釋放內存。</p>
</aside>
<p>命令是一次性為我們很快地贏得了一個優點。
為了讓指令可被取消，我們為每個類定義另一個需要實現的方法：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Command</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Command</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">undo</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p><code>undo()</code>方法回滾了<code>execute()</code>方法造成的遊戲狀態改變。
這裡是添加了撤銷功能後的移動命令：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MoveUnitCommand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Command</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">MoveUnitCommand</span><span class="p">(</span><span class="n">Unit</span><span class="o">*</span> <span class="n">unit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">unit_</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span>
    <span class="n">xBefore_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">yBefore_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
    <span class="n">y_</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 保存移動之前的位置</span>
    <span class="c1">// 這樣之後可以複原。</span>

    <span class="n">xBefore_</span> <span class="o">=</span> <span class="n">unit_</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">();</span>
    <span class="n">yBefore_</span> <span class="o">=</span> <span class="n">unit_</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">();</span>

    <span class="n">unit_</span><span class="o">-&gt;</span><span class="n">moveTo</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">undo</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">unit_</span><span class="o">-&gt;</span><span class="n">moveTo</span><span class="p">(</span><span class="n">xBefore_</span><span class="p">,</span> <span class="n">yBefore_</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Unit</span><span class="o">*</span> <span class="n">unit_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">xBefore_</span><span class="p">,</span> <span class="n">yBefore_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p><span name="memento"></span>注意我們為類添加了更多的狀態。
當單位移動時，它忘記了它之前是什麼樣的。
如果我們想要撤銷這個移動，我們需要記得單位之前的狀態，也就是<code>xBefore_</code>和<code>yBefore_</code>的作用。</p>
<aside name="memento">
<p>這看上去是<a href="http://en.wikipedia.org/wiki/Memento_pattern"
class="gof-pattern">備忘錄</a>模式使用的地方，它從來沒有有效的工作過。
由於命令趨向于修改對象狀態的一小部分，對數據其他部分的快照就是浪費內存。手動存儲改動的部分消耗更小。</p>
<p><a href="http://en.wikipedia.org/wiki/Persistent_data_structure">*持久化資料結構*</a>是另一個選項。
使用它，每次修改對象都返回一個新對象，保持原來的對象不變。巧妙的實現下，這些新對象與之前的對象共享數據，所以比克隆整個對象開銷更小。</p>
<p>使用持久化資料結構，每條命令都存儲了命令執行之前對象的引用，而撤銷只是切換回之前的對象。</p>
</aside>
<p>為了讓玩家撤銷移動，我們記錄了執行的最後命令。當他們按下<code>control+z</code>時，我們調用命令的<code>undo()</code>方法。
（如果他們已經撤銷了，那麼就變成了“重做”，我們會再一次執行命令。）</p>
<p>支持多重的撤銷也不太難。
我們不單單記錄最後一條指令，還要記錄指令列表，然後用一個引用指向“當前”的那個。
當玩家執行一條命令，我們將其添加到列表，然後將代表“當前”的指針指向它。</p>
<p><img src="images/command-undo.png" alt="從舊到新排列的命令棧。
一個當前箭頭指向一條命令，一個“撤銷”箭頭指向之前的命令，一個“重做”指向之後的命令" /></p>
<p><span name="replay"></span>
當玩家選擇“撤銷”，我們撤銷現在的命令，將代表當前的指針往後退。
當他們選擇“重做”，我們將代表當前的指針往前進，執行該指令。
如果在撤銷後選擇了新命令，那麼清除命令列表中當前的指針所指命令之後的全部命令。</p>
<p>第一次在關卡編輯器中實現這點時，我覺得自己簡直就是個天才。
我驚訝于它如此的簡明有效。
你需要約束自己，保證每個數據修改都通過命令完成，一旦你做到了，餘下的都很簡單。</p>
<aside name="replay">
<p>重做在遊戲中並不常見，但重<em>放</em>常見。
一種簡單的重放實現是記錄遊戲每幀的狀態，這樣它可以回放，但那會消耗太多的內存。</p>
<p>相反，很多遊戲記錄每個實體每幀運行的命令。
為了重放遊戲，引擎只需要正常運行遊戲，執行之前存儲的命令。</p>
</aside>
<h2><a href="#用類還是用函數？" name="用類還是用函數？">用類還是用函數？</a></h2>
<p>早些時候，我說過命令與第一公民函數或者閉包類似，
但是在這裡展現的每個例子都是通過類完成的。
如果你更熟悉函數式編程，你也許會疑惑函數都在哪裡。</p>
<p>我用這種方式寫例子是因為C++對第一公民函數支持非常有限。
函數指針沒有狀態，函子很奇怪而且仍然需要定義類，
在C++11中的lambda演算需要大量的人工記憶輔助才能使用。</p>
<p><span name="some"></span>
這並<em>不是</em>說你在其他語言中不可以用函數來完成命令模式。
如果你使用的語言支持閉包，不管怎樣，快去用它！
在某種程度上，命令模式是為一些沒有閉包的語言模擬閉包。</p>
<aside name="some">
<p>(我說<em>某種程度上</em>是因為，即使是那些支持閉包的語言，
為命令建立真正的類或者結構也是很有用的。
如果你的命令擁有多重操作（比如可撤銷的命令），
將其全部映射到同一函數中並不優雅。)</p>
<p>定義一個有欄位的真實類能幫助讀者理解命令包含了什麼數據。
閉包是自動包裝狀態的完美解決方案，但它們過于自動化而很難看清包裝的真正狀態有哪些。</p>
</aside>
<p>舉個例子，如果我們使用javascript來寫遊戲，那麼我們可以用這種方式來寫讓單位移動的命令：</p>
<div class="codehilite"><pre><span></span><span class="kd">function</span> <span class="nx">makeMoveUnitCommand</span><span class="p">(</span><span class="nx">unit</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 這個函數就是命令對象:</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">unit</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>我們可以通過一對閉包來為撤銷提供支持：</p>
<div class="codehilite"><pre><span></span><span class="kd">function</span> <span class="nx">makeMoveUnitCommand</span><span class="p">(</span><span class="nx">unit</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">xBefore</span><span class="p">,</span> <span class="nx">yBefore</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">execute</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">xBefore</span> <span class="o">=</span> <span class="nx">unit</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span>
      <span class="nx">yBefore</span> <span class="o">=</span> <span class="nx">unit</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span>
      <span class="nx">unit</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">undo</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">unit</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="nx">xBefore</span><span class="p">,</span> <span class="nx">yBefore</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>


<p>如果你習慣了函數式編程風格，這種做事的方法是很自然的。
如果你沒有，我希望這章可以幫你瞭解一些。
對於我而言，命令模式展現了函數式範式在很多問題上的高效性。</p>
<h2><a href="#參見" name="參見">參見</a></h2>
<ul>
<li>
<p>你最終可能會得到很多不同的命令類。
為了更容易實現這些類，定義一個具體的基類，包含一些能定義行為的高層方法，往往會有幫助。
這將命令的主體<code>execute()</code>轉到<a href="subclass-sandbox.html" class="pattern">子類沙箱</a>中。</p>
</li>
<li>
<p>在上面的例子中，我們明確地指定哪個角色會處理命令。
在某些情況下，特別是當對象模型分層時，也可以不這麼簡單粗暴。
對象可以響應命令，或者將命令交給它的從屬對象。
如果你這樣做，你就完成了一個<a class="gof-pattern" href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">職責鏈模式</a>。</p>
</li>
</ul>
<p><span name="singleton"></span>
* 有些命令是無狀態的純粹行為，比如第一個例子中的<code>JumpCommand</code>。
在這種情況下，有多個實例是在浪費內存，因為所有的實例是等價的。
可以用<a class="gof-pattern" href="flyweight.html">享元模式</a>解決。</p>
<aside name="singleton">
<p>你可以將其實現為<a href="singleton.html" class="gof-pattern">單例</a>，但真朋友不會讓你用單例。</p>
</aside>
<nav>
  <span class="prev">&larr; <a href="design-patterns-revisited.html">上一章</a></span>
  <span class="next"><a href="flyweight.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
