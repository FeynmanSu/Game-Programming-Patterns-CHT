^title 組件模式
^section Decoupling Patterns

## 意圖

*允許單一的實體跨越多個領域而不會導致這些領域彼此耦合。*

## 動機

<span name="baker"></span>

讓我們假設我們正構建平台跳躍遊戲。
意大利水管工已經有人做了，因此我們將出動丹麥麵包師，Bj?rn。
照理說，會有一個類來表示友好的糕點廚師，包含他在比賽中做的一切。

<aside name="baker">

像這樣的遊戲創意導致了我是程序員而不是設計師。

</aside>

由於玩家控制他，這意味著需要讀取控製器的輸入然後轉化為動作。
而且，當然，他需要與關卡相互作用，所以要引入物理和碰撞。
一旦這樣做了，他必須在屏幕上出現，所以要引入動畫和渲染。
他可能還會播放一些聲音。

等一下，這在失控。軟件體繫結構101課程告訴我們，程序的不同領域應保持分離。
如果我們做一個文字處理器，處理打印的代碼不應該受加載和保存檔案的代碼影響。
遊戲和企業應用程序的領域不盡相同，但該規則仍然適用。

我們希望AI，物理，渲染，聲音和其他領域域儘可能相互不瞭解，
但現在我們將所有這一切擠在一個類中。
我們已經看到了這條路通往何處：5000行的巨大代碼檔案，哪怕是你們團隊中最勇敢的程序員也不敢打開。

這工作對能馴服他的少數人是有趣的，但對其他人是地獄。
這麼大的類意味著，即使是看似微不足道的變化亦可有深遠的影響。
很快，為類添加*錯誤*的速度明顯快于添加*功能*的速度。

### 快刀斬亂麻

<span name="coupling"></span>

比起單純的規模問題，更糟糕的是耦合。
在遊戲中所有不同的系統被綁成了一個巨大的代碼球：

^code gordian

任何試圖改變上面代碼的程序員，都需要物理，圖形和聲音的相關知識，以確保沒破壞什麼。

<aside name="coupling">

這樣的耦合在*任何*遊戲中出現都是個問題，但是在使用並發的現代遊戲中尤其糟糕。
在多核硬件上，讓代碼同時在多個線程上運行是至關重要的。
將遊戲分割到線程的一種通用方法是通過領域劃分——在一個核上運行AI代碼，在另一個上播放聲音，在第三個上渲染，等等。

一旦你這麼做了，在領域間保持解耦就是至關重要的，這是為了避免死鎖或者其他惡魔般的並發問題。
如果某個函數從一個線程上調用`UpdateSounds()`方法，從另一個線程上調用`RenderGraphics()`方法，那它是在自找麻煩。

</aside>

這兩個問題互相混合;這個類涉及太多的域，每個程序員都得接觸它，
但它又太過巨大，這就變成了一場噩夢。
如果變得夠糟糕，程序員會黑入代碼庫的其他部分，僅僅為了躲開這個像毛球一樣的`Bjorn`類。

### 快刀斬亂麻

我們可以像亞歷山大大帝一樣解決這個問題——快刀斬亂麻。
按領域將`Bjorn`類切片成相互獨立的部分。
例如，我們抽出所有處理用戶輸入的代碼，將其移動到一個單獨的`InputComponent`類。
`Bjorn`擁有這個部件的一個實例。我們將對`Bjorn`接觸的每個領域重複這一過程。

當完成後，我們將`Bjorn`大多數的東西都抽走了。
剩下的是一個薄殻包著所有的組件。
通過將類劃分為多個小類，我們已經解決了這個問題。但我們完成了遠遠不止這些。

### 寬鬆的結果

我們的組件類現在解耦了。
儘管`Bjorn`有`PhysicsComponent`和`GraphicsComponent`，
但這兩部分都不知道對方的存在。
這意味著處理物理的人可以修改組件而不需要瞭解圖形，反之亦然。

在實踐中，這些部件需要在它們之間有*一些*相互作用。
例如，AI組件可能需要告訴物理組件Bj?rn試圖去哪裡。
然而，我們可以限制這種交互在*確實*需要交互的組件之間，
而不是把它們圍在同一個圍欄裡。

### 綁到一起

<span name="inheritance"></span>

這種設計的另一特性是，組件現在是可復用的包。
到目前為止，我們專注于麵包師，但是讓我們考慮幾個遊戲世界中其他類型的對象。
*裝飾* 是玩家看到但不能交互的事物：灌木，雜物等視覺細節。
*道具* 像*裝飾*，但可以交互：箱，巨石，樹木。
*區域* 與裝飾相反——無形但可互動。
它們是很好的觸發器，比如在Bj?rn進入區域時觸發過場動畫。

<aside name="inheritance">

當面向對象語言第一次接觸這個場景時，繼承是它箱子裡最閃耀的工具。
它被認為是代碼無限重用之錘，編程者常常揮舞著它。
然而我們痛苦地學到，事實上它是一把重鎚。
繼承有它的用處，但對簡單的代碼重用太過複雜。

相反，在今日軟件設計的趨勢是儘可能使用組件代替繼承。
不是讓兩個類*繼承*同一類來分享代碼，而是讓它們*擁有同一個類的實例*。

</aside>

現在，考慮如果不用組件，我們將如何建立這些類的繼承層次。第一遍可能是這樣的：

<img src="images/component-uml.png" alt="類的層次圖。區域有碰撞檢測代碼並繼承遊戲對象。裝飾也繼承遊戲對象而且有渲染代碼。道具繼承區域，但是有了多餘的渲染代碼。" />

<span name="diamond"></span>

我們有`GameObject`基類，包含位置和方向之類的通用部分。
`Zone`繼承它，增加了碰撞檢測。
同樣，`Decoration`繼承`GameObject`，並增加了渲染。
`Prop`繼承`Zone`，因此它可以重用碰撞代碼。
然而，`Prop`不能*同時*繼承`Decoration`來重用*渲染*，
否則就會造成致命菱形結構。

<aside name="diamond">

“致命菱形”發生在類繼承了多個類，而這多個類中有兩個繼承同一基類時。
介紹它造成的痛苦超過了本書的範圍，但它被稱為“致命”是有原因的。

</aside>

我們可以反過來讓`Prop`繼承`Decoration`，但隨後不得不重複*碰撞檢測*代碼。
無論哪種方式，沒有乾淨的方式重用碰撞和渲染代碼而不訴諸多重繼承。
唯一的其他選擇是一切都繼承`GameObject`，
但隨後`Zone`會浪費內存在並不需要的渲染數據上，
`Decoration`在物理效果上有同樣的浪費。

<span name="menu"></span>

現在，讓我們嘗試用組件。子類將徹底消失。
取而代之的是一個`GameObject`類和兩個組件類：`PhysicsComponent`和`GraphicsComponent`。
裝飾是個簡單的`GameObject`，包含`GraphicsComponent`但沒有`PhysicsComponent`。
區域與其恰好相反，而道具包含兩種組件。
沒有代碼重複，沒有多重繼承，只有三個類，而不是四個。

<aside name="menu">

可以拿飯店菜單打比方。如果每個實體是一個類，那就只能訂套餐。
我們需要為每種*可能*的組合定義各自的類。
為了滿足每位用戶，我們需要十幾種套餐。

組件是照單點菜——每位顧客都可以選他們想要的，菜單記錄可選的菜式。

</aside>

對對象而言，組件是即插即用的。
將不同的可重用部件插入對象，我們就能構建複雜具有豐富的行為實體。
就像軟件中的戰神金剛。

## 模式

<span name="component"></span>

**單一實體跨越了多個領域**。為了保持領域之間相互分離，將每部分代碼放入**各自的組件類**中。
實體被簡化為*組件的容器*。

<aside name="component">

“組件”，就像“對象”，在編程中意味任何東西也不意味任何東西。
正因如此，它被用來描述一些概念。
在商業軟件中，“組件”設計模式描述通過網絡解耦的服務。

我試圖從遊戲中找到無關這個設計模式的另一個名字，但“組件”看來是最常用的術語。
由於設計模式是關於記錄已存的實踐，我沒有創建新術語的餘地。
所以，跟著XNA，Delta3D和其他人的腳步，我稱之為“組件”。

</aside>

## 何時使用

組件通常在定義遊戲實體的核心部分中使用，但它們在其他地方也有用。
這個模式在如下情況中可以使用：

* 有一個涉及了多個領域的類，而你想保持這些領域互相隔離。

* 一個類正在變大而且越來越難以使用。

* 想要能定義一系列分享不同能力的類，但是使用繼承無法讓你精確選取要重用的部分。

## 記住

組件模式比簡單地向類中添加代碼增加了一點點複雜性。
每個概念上的“對象”要組成真正對象需要實例化，初始化，然後正確的連接。
不同組件間溝通會有些困難，而控制它們如何使用內存就更加複雜。

對於大型代碼庫，為瞭解耦和重用而付出這樣的複雜度是值得的。
但是在使用這種模式之前，保證你沒有為了不存在的問題而“過度設計”。

<span name="perf"></span>

使用組件的另一後果是，需要多一層跳轉才能做要做的事。
拿到容器對象，獲得相應的組件，*然後* 你才能做想做的事情。
在性能攸關的內部循環中，這種跳轉也許會導致糟糕的性能。

<aside name="perf">

這是硬幣的兩面。組件模式通常可以*增進*性能和緩存一致性。
組件讓使用<a class="pattern" href="data-locality.html">數據局部性</a>模式的CPU更容易地組織數據。

</aside>

## 示例代碼

我寫這本書的最大挑戰之一就是搞明白如何隔離各個模式。
許多設計模式包含了不屬於這種模式的代碼。
為了將提取模式的本質，我儘可能的消減代碼，
但是在某種程度上，這就像沒有衣服還要說明如何整理衣櫃。

說明組件模式尤其困難。
如果看不到它解耦的各個領域的代碼，你就不能獲得正確的體會，
因此我會多寫一些有關於Bj?rn的代碼。
這個模式事實上只關於將組件變為*類*，但類中的代碼可以幫助表明類是做什麼用的。
它是偽代碼——它調用了其他不存在的類——但這應該可以讓你理解我們正在做什麼。

### 單塊類

<span name="cat"></span>

為了清晰的看到這個模式是如何應用的，
我們先展示一個`Bjorn`類，
它包含了所有我們需要的事物，但是*沒有*使用這個模式：

<aside name="cat">

我應指出在代碼使用角色的名字總是個壞主意。市場部有在發售之前改名字的壞習慣。
“焦點測試表明，在11歲到15歲的男性不喜歡&lsquo;Bj?rn&rsquo;，請改為&lsquo;Sven&rsquo”。

這就是為什麼很多軟件項目使用內部代碼名。
而且比起告訴人們你在完成“Photoshop的下一版本”，告訴他們你在完成“大電貓”更有趣。

</aside>

^code 1

`Bjorn`有個每幀調用的`update()`方法。

^code monolithic-update

它讀取操縱桿以確定如何加速麵包師。
然後，用物理引擎解析新位置。
最後，將Bj?rn渲染至屏幕。

這裡的示例實現平凡而簡單。
沒有重力，動畫，或任何讓人物有趣的其他細節。
即便如此，我們可以看到，已經出現了同時消耗多個程序員時間的函數，而它開始變得有點混亂。
想象增加到一千行，你就知道這會有多難受了。

### 分離領域

從一個領域開始，將`Bjorn`的代碼去除一部分，歸入分離的組件類。
我們從首個執行的領域開始：輸入。
`Bjorn`做的頭件事就是讀取玩家的輸入，然後基于此調整它的速度。
讓我們將這部分邏輯移入一個分離的類：

^code 2

很簡單吧。我們將`Bjorn`的`update()`的第一部分取出，放入這個類中。
對`Bjorn`的改變也很直接：

^code 3

`Bjorn`現在擁有了一個`InputComponent`對象。
之前它在`update()`方法中直接處理用戶輸入，現在委託給組件：

^code 4

我們才剛開始，但已經擺脫了一些耦合——`Bjorn`主體現在已經與`Controller`無關了。這會派上用場的。

### 將剩下的分割出來

現在讓我們對物理和圖像代碼繼續這種剪切粘貼的工作。
這是我們新的 `PhysicsComponent`：

^code 5

為了將物理*行為*移出`Bjorn`類，你可以看到我們也移出了*數據*：`Volume`對象已經是組件的一部分了。

最後，這是現在的渲染代碼：

^code 6

我們几乎將所有的東西都移出來了，所以麵包師還剩下什麼？沒什麼了：

^code 7

`Bjorn`類現在基本上就做兩件事：擁有定義它的組件，以及在不同域間分享的數據。
有兩個原因導致位置和速度仍然在`Bjorn`的核心類中：
首先，它們是“泛領域”狀態——几乎每個組件都需要使用它們，
所以我們想要提取它出來時，哪個組件*應該*擁有它們並不明確。

第二，也是更重要的一點，它給了我們無需讓組件耦合就能溝通的簡易方法。
讓我們看看能不能利用這一點。

### 機器人Bj?rn

到目前為止，我們將行為歸入了不同的組件類，但還沒將行為*抽象*出來。
`Bjorn`仍知道每個類的具體定義的行為。讓我們改變這一點。

取出處理輸入的部件，將其藏在介面之後，將`InputComponent`變為抽象基類。

^code 8

然後，將現有的處理輸入的代碼取出，放進一個實現介面的類中。

^code 9

我們將`Bjorn`改為只擁有一個指向輸入組件的指針，而不是擁有一個內聯的實例。

^code 10

現在當我們實例化`Bjorn`，我們可以傳入輸入組件使用，就像下面這樣：

^code 11

這個實例可以是任何實現了抽象`InputComponent`介面的類型。
我們為此付出了代價——`update()`現在是虛方法調用了，這會慢一些。這一代價的回報是什麼？

大多數的主機需要遊戲支持“演示模式”。
如果玩家停在主菜單沒有做任何事情，遊戲就會自動開始運行，直到接入一個玩家。
這讓屏幕上的主菜單看上去更有生機，同時也是銷售商店裡很好的展示。

隱藏在輸入組件後的類幫我們實現了這點，
我們已經有了具體的`PlayerInputComponent`供在玩遊戲時使用。
現在讓我們完成另一個：

^code 12

當遊戲進入演示模式，不像之前演示的那樣構造Bj?rn，
我們將它和一個新組件連接起來：

^code 13

<span name="coffee"></span>

現在，只需要更改組件，我們就有了為演示模式而設計的電腦控制的玩家。
我們可以重用所有Bj?rn的代碼——物理和圖像都不知道這裡有了變化。
也許我有些奇怪，但這就是每天能讓我從起床的事物。

<aside name="coffee">

那個，還有咖啡。熱氣騰騰的咖啡。

</aside>

### 刪掉Bj?rn？

如果你看看現在的`Bj?rn`類，你會意識到那裡完全沒有“Bj?rn”——那只是個組件包。
事實上，它是個好候選人，能夠作為*每個*遊戲中的對象都能繼承的“遊戲對象”基類。
我們可以像弗蘭肯斯坦一樣，通過挑選拼裝部件構建任何對象。

讓我們將剩下的兩個具體組件——物理和圖像——像輸入那樣藏到介面之後。

^code 14

<span name="id"></span>

然後將`Bj?rn`改為使用這些介面的通用`GameObject`類。

^code 15

<aside name="id">

有些人走的更遠。
不使用包含組件的`GameObject`，遊戲實體只是一個ID，一個數字。
每個組件都知道它們連接的實體ID，然後管理分離的組件。

這些[實體組件系統](http://en.wikipedia.org/wiki/Entity_component_system)將組件發揮到了極致，讓你向實體添加組件而無需通知實體。
<a href="data-locality.html" class="pattern">數據局部性</a>一章有更多細節。

</aside>

我們現有的具體類被重命名並實現這些介面：

^code 16

現在我們無需為Bj?rn建立具體類，就能構建擁有所有Bj?rn行為的對象。

<span name="factory"></span>

^code 17

<aside name="factory">

這個`createBjorn()`函數是，當然，經典GoF<a class="gof-pattern" href="http://c2.com/cgi/wiki?FactoryMethod">工廠模式</a>的例子。

</aside>

通過用不同組件實例化`GameObject`，我們可以構建遊戲需要的任何對象。

## 設計決策

這章中你最需要回答的設計問題是“我需要什麼樣的組件？”
回答取決於你遊戲的需求和風格。
引擎越大越複雜，你就想將組件劃分得更細。

除此之外，還有幾個更具體的選項要回答：

### 對象如何獲取組件？

一旦將單塊對象分割為多個分離的組件，就需要決定誰將它們拼到一起。

* **如果對象創建組件：**

    * *這保證了對象總是能拿到需要的組件。*
    你永遠不必擔心某人忘記連接正確的組件然後破壞了整個遊戲。容器類自己會處理這個問題。

    * *重新設置對象比較困難。*
    這個模式的強力特性之一就是隻需重新組合組件就可以創建新的對象。
    如果對象總是用硬編碼的組件組裝自己，我們就無法利用這個特性。

* **如果外部代碼提供組件：**

     * *對象更加靈活。*
     我們可以提供不同的組件，這樣就能改變對象的行為。
     通過共用組件，對象變成了組件容器，我們可以為不同目的一遍又一遍重用它。

    * *對象可以與具體的組件類型解耦。*
    如果我們允許外部代碼提供組件，好處是也可以傳遞*派生*的組件類型。
    這樣，對象只知道組件*介面*而不知道組件的具體類型。這是一個很好的封裝結構。

### 組件之間如何通信？

完美解耦的組件不需要考慮這個問題，但在真正的實踐中行不通。
事實上組件屬於*同一*對象暗示它們屬於需要相互協同的更大整體的一部分。
這就意味著通信。

所以組件如何相互通信呢？
這裡有很多選項，但不像這本書中其他的“選項”，它們相互並不衝突——你可以在一個設計中支持多種方案。

* *通過修改容器對象的狀態：*

    * *這保持組件解耦。*
    當我們的`InputComponent`設置了Bj?rn的速度，而後`PhysicsComponent`使用它，
    這兩個組件都不知道對方的存在。在它們的理解中，Bj?rn的速度是被黑魔法改變的。

    * *需要將組件分享的任何數據存儲在容器類中。*
    通常狀態只在幾個組件間共享。比如，動畫組件和渲染組件需要共享圖形專用的信息。
    將信息存入容器類會讓*所有*組件都獲得這樣的信息。

        更糟的是，如果我們為不同組件配置使用相同的容器類，最終會浪費內存存儲不被*任何*對象組件需要的狀態。
        如果我們將渲染專用的數據放入容器對象中，任何隱形對象都會無益的消耗內存。

    * *這讓組件的通信基于組件運行的順序。*
    在同樣的代碼中，原先一整塊的`update()`代碼小心地排列這些操作。
    玩家的輸入修改了速度，速度被物理代碼使用並修改位置，位置被渲染代碼使用將Bj?rn繪到該有的地方。
    當我們將這些代碼劃入組件時，還是得小心翼翼的保持這種操作順序。

        <span name="pure"></span>

        如果我們不那麼做，就引入了 微妙而難以追蹤的漏洞。
        比如，我們*先*更新圖形組件，就錯誤地將Bj?rn渲染在他*上一幀*而不是這一幀所處的位置上。
        如果你考慮更多的組件和更多的代碼，那你可以想象要避免這樣的錯誤有多麼困難了。

        <aside name="pure">

        大量這樣共享狀態的代碼很難正確完成讀寫的相同數據。
        這就是為什麼學術界花時間研究完全函數式語言，比如Haskell，那里根本沒有可變狀態。

        </aside>

* *通過它們之間相互引用：*

    這裡的思路是組件有要交流的組件的引用，這樣它們直接交流，無需通過容器類。

    假設我們想讓Bj?rn跳躍。圖形代碼想知道它需要用跳躍圖像還是不用。
    這可以通過詢問物理引擎它當前是否在地上來確定。一種簡單的方式是圖形組件直接知道物理組件的存在：

    ^code 18

    當構建Bj?rn的`GraphicsComponent`時，我們給它相應的`PhysicsComponent`引用。

    * *簡單快捷。*
    通信是一個對象到另一個的直接方法調用。組件可以調用任一引用對象的方法。做什麼都可以。

    * *兩個組件緊綁在一起。*
    這是什麼都可以的壞處。我們向使用整塊類又退回了一步。
    這比只用單一類好一點，至少我們現在只是把需要通信的類綁在一起。

* *通過發送消息：*

    * 這是最複雜的選項。我們可以在容器類中建小小的消息系統，允許組件相互發送消息。

        下面是一種可能的實現。我們從每個組件都會實現的`Component`介面開始：

        ^code 19

        它有一個簡單的`receive()`方法，每個需要接受消息的組件類都要實現它。
        這裡，我們使用一個`int`來定義消息，但更完整的消息實現應該可以附加數據。

        然後，向容器類添加發送消息的方法。

        ^code 20

        <span name="queue"></span>

        現在，如果組件能夠接觸容器，它就能向容器發送消息，直接向所有的組件廣播。
        （包括了原先發送消息的組件，小心別陷入消息的無限循環中！）這會造成一些結果：

        <aside name="queue">

        如果你真的樂意，甚至可以將消息存儲在*隊列*中，晚些發送。
        要知道更多，看看<a href="event-queue.html" class="pattern">事件隊列</a>。

        </aside>

    <span name="mediator"></span>

    * *同級組件解耦。*
    通過父級容器對象，就像共享狀態的方案一樣，我們保證了組件之間仍然是解耦的。
    使用了這套系統，組件之間唯一的耦合是它們發送的消息。

        <aside name="mediator">

        GoF稱之為<a class="gof-pattern" href="http://c2.com/cgi-bin/wiki?MediatorPattern">中介</a>模式——兩個或更多的對象通過中介對象通信。
        現在這種情況下，容器對象本身就是中介。

        </aside>

     * *容器類很簡單。*
     不像使用共享狀態那樣，容器類無需知道組件使用了什麼數據，它只是將消息發送出去。
     這可以讓組件發送領域特有的數據而無需打擾容器對象。

不出意料的，這裡沒有最好的答案。這些方法你最終可能都會使用一些。
共享狀態對於每個對象都有的數據是很好用的——比如位置和大小。

有些不同領域仍然緊密相關。想想動畫和渲染，輸入和AI，或物理和粒子。
如果你有這樣一對分離的組件，你會發現直接相互引用也許更加容易。

消息對於“不那麼重要”的通信很有用。
發送後不管的特性對物理組件發現事物碰撞後發送消息，讓音樂組件播放聲音這種事情是很有效的。

就像以前一樣，我建議你從簡單的開始，然後如果需要的話，加入其他的通信路徑。

## See Also

## 參見

* [Unity](http://unity3d.com)核心架構中[`GameObject`](http://docs.unity3d.com/Documentation/Manual/GameObjects.html)類完全根據這樣的原則設計[components](http://docs.unity3d.com/Manual/UsingComponents.html)。

* 開源的[Delta3D](http://www.delta3d.org)引擎有`GameActor`基類通過`ActorComponent`實現了這種模式。

* 微軟的<a href="http://creators.xna.com/en-US/">XNA</a>遊戲框架有一個核心的`Game`類。它擁有一系列`GameComponent`對象。我們在遊戲實體層使用組件，XNA在遊戲主對象上實現了這種模式，但意圖是一樣的。

* 這種模式與GoF的<a class="gof-pattern" href="http://c2.com/cgi-bin/wiki?StrategyPattern">策略模式</a>類似。
兩種模式都是將對象的行為取出，劃入單獨的重述對象。
與對象模式不同的是，分離的策略模式通常是無狀態的——它封裝了算法，而沒有數據。
它定義了對象*如何*行動，但沒有定義對象*是*什麼。

    組件更加重要。它們經常保存了對象的狀態，這有助于確定其真正的身份。
    但是，這條界限很模糊。有一些組件也許根本沒有任何狀態。
    在這種情況下，你可以在不同的容器對象中使用相同的組件*實例*。這樣看來，它的行為確實更像一種策略。
