<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />

<title>雙緩衝模式 &middot; Sequencing Patterns &middot; 遊戲設計模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<!--
delete the font style for english.
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
-->
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="sequencing-patterns.html">上一章</a></span>
  <span class="next"><a href="game-loop.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
<h1>雙緩衝模式</h1>
<h1 class="book"><a href="/">遊戲設計模式</a><span class="section"><a href="sequencing-patterns.html">Sequencing Patterns</a></span></h1>
<h2><a href="#意圖" name="意圖">意圖</a></h2>
<p><em>用序列的操作模擬瞬間或者同時發生的事情。</em></p>
<h2><a href="#動機" name="動機">動機</a></h2>
<p><span name="sequential"></span>
電腦具有強大的序列化處理能力。
它的力量來自于將大的任務分解為小的步驟，這樣可以一步接一步的完成。
但是，通常用戶需要看到事情發生在瞬間或者讓多個任務同時進行。</p>
<aside name="sequential">
<p>使用線程和多核架構讓這種說法不那麼正確了，但哪怕使用多核，也只有一些操作可以同步運行。</p>
</aside>
<p>一個典型的例子，也是每個遊戲引擎都得掌控的問題，渲染。
當遊戲渲染玩家所見的世界時，它同時需要處理一堆——遠處的山，起伏的丘陵，樹木，每個都在各自的循環中處理。
如果在用戶<em>觀察</em>時增量做這些，連續世界的幻覺就會被打破。
場景必須快速流暢地更新，顯示一系列完整的幀，每幀都是立即出現的。</p>
<p>雙緩衝解決了這個問題，但是為了理解其原理，讓我們首先的複習下計算機是如何顯示圖形的。</p>
<h3><a href="#計算機圖形系統是如何工作的（概述）" name="計算機圖形系統是如何工作的（概述）">計算機圖形系統是如何工作的（概述）</a></h3>
<p><span name="scan"></span>
在電腦屏幕上顯示圖像是一次繪製一個像素點。
它從左到右掃瞄每行像素點，然後移動至下一行。
當抵達了右下角，它退回左上角重新開始。
它做得飛快——每秒六十次——因此我們的眼睛無法察覺。
對我們來說，這是一整張靜態的彩色像素——一張圖像。</p>
<aside name="scan">
<p>這個解釋是，額，“簡化過的”。
如果你是底層軟件開發人員，跳過下一節吧。
你對這章的其餘部分已經瞭解的夠多了。
如果你不是，這部分的目標是給你足夠的背景知識，理解等要討論的設計模式。</p>
</aside>
<p>你可以將整個過程想象為軟管向屏幕噴灑像素。
獨特的像素從軟管的後面流入，然後在屏幕上噴灑，每次對一個像素涂一點顏色。
所以軟管怎麼知道哪種顏色要噴到哪裡？</p>
<p><span name="color"></span>
在大多數電腦上，答案是從<em>幀緩衝</em>中獲知這些信息。
幀緩衝是內存中的色素數組，RAM中每兩個位元組代表表示一個像素點的顏色。
當軟管向屏幕噴灑時，它從這個數組中讀取顏色值，每次一個位元組。</p>
<aside name="color">
<p>在位元組值和顏色之間的映射通常由系統的<em>像素格式</em>和<em>色深</em>來指定。
在今日多數遊戲主機上，每個像素都有32位，紅綠藍三個各占八位，剩下的八位保留作其他用途。</p>
</aside>
<p>最終，為了讓遊戲顯示在屏幕中，我們需要做的就是寫入這個數組。
我們瘋狂擺弄的圖形算法最終都到了這裡：設置幀緩衝中的位元組值。
但這裡有個小問題。</p>
<p>早先，我說過計算機是順序處理的。
如果機器在運行一塊渲染代碼，我們不指望它同時還能做些別的什麼事。
這通常是沒啥問題，但是有些事<em>確實</em>在程序運行時發生。
其中一件是，當遊戲運行時，視頻輸出正在<em>不斷</em>從幀緩衝中讀取數據。
這可能會為我們帶來問題。</p>
<p>假設我們要在屏幕上顯示一張笑臉。
程序在幀緩衝上開始循環，為像素點塗色。
我們沒有意識到的是，在寫入的同時，視頻驅動正在讀取它。
當它掃瞄過已寫的像素時，笑臉開始浮現，但是之後它進入了未寫的部分，就將沒有寫的像素繪製到了屏幕上。結果就是<em>撕裂</em>，你在屏幕上看到了繪製到一半的圖像，這是可見的可怕漏洞。</p>
<p><span name="tearing"></span></p>
<p><img src="images/double-buffer-tearing.png" alt="描述了正在渲染的幀的一系列圖片。一個指針在像素上寫入，與此同時，另一個指針正在讀取。讀取的指針越過了寫入的指針，然後開始讀取未曾渲染的像素點。" /></p>
<aside name="tearing">
<p>顯卡設備讀取的緩衝幀正是我們繪製像素的那塊(Fig. 1)。
顯卡最終追上了渲染器，然後越過它，讀取了還沒有寫入的像素(Fig. 2)。
我們完成了繪製，但驅動沒有收到那些新像素。</p>
<p>結果(Fig. 4)是用戶只看到了一半的繪製結果。
我稱它為“哭臉”，笑臉看上去下半部是撕裂的。</p>
</aside>
<p>這就是我們需要這個設計模式的原因。
程序一次渲染一個像素，但是顯示需要一次全部看到——在這幀中啥也沒有，下一幀笑臉全部出現。
雙緩衝解決了這個問題。我會用類比來解釋。</p>
<h3><a href="#表演1，場景1" name="表演1，場景1">表演1，場景1</a></h3>
<p>想象玩家正在觀看我們的表演。
在場景一結束而場景二開始時，我們需要改變舞台設置。
如果讓場務在場景結束後進去拖動東西，在場景的連貫性就被打破了。
我們可以減弱燈光（這是劇院真正所做的），但是觀眾還是知道<em>有什麼</em>在進行，而我們想在場景間毫無跳躍的轉換。</p>
<p><span name="stage"></span>
消耗一些地皮，我們想到了一個聰明的解決方案：建<em>兩個</em>舞台，觀眾兩個都能看到。
每個有它自己的一組燈光。我們稱這些舞台為舞台A和舞台B。
場景一在舞台A上。同時場務在處于黑暗之中的舞台B佈置場景二。
當場景一完成後，切斷場景A的燈光，將打開場景B的燈光。觀眾看向新舞台，場景二立即開始。</p>
<p>同時，場務到了黑咕隆咚的舞台<em>A</em>，收拾了場景一然後佈置場景<em>三</em>。
一旦場景二結束，將燈光轉回舞台A。
我們在整場表演中進行這樣的活動，使用黑暗的舞台作為佈置下一場景的工作區域。
每一次場景轉換，只是在兩個舞台間切換燈光。
觀眾獲得了連續的體驗，場景轉換時沒有感到任何中斷。他們從來沒有見到場務。</p>
<aside name="stage">
<p>使用單面鏡以及其他的巧妙佈置，你可以真正的在同一<em>位置</em>佈置兩個舞台。
隨著燈光切換，觀眾看到了不同的舞台，無需看向不同的地方。
如何這樣佈置舞台就留給讀者做練習吧。</p>
</aside>
<h3><a href="#重新回到圖形" name="重新回到圖形">重新回到圖形</a></h3>
<p><span name="sync"></span>
這就是雙緩衝的工作原理，
這就是你看到的几乎每個遊戲背後的渲染系統。
不只用一個幀緩衝，我們用<em>兩個</em>。其中一個代表現在的幀，即類比中的舞台A，也就是說是顯卡讀取的那一個。
GPU可以想什麼時候掃就什麼時候掃。</p>
<aside name="sync">
<p>但不是<em>所有</em>的遊戲主機都是這麼做的。
更老的簡單主機中，內存有限，需要小心的同步繪製和渲染。那很需要技巧。</p>
</aside>
<p>同時，我們的渲染代碼正在寫入<em>另一個</em>幀緩衝。
即黑暗中的舞台B。當渲染代碼完成了場景的繪製，它將通過<em>交換</em>緩存來切換燈光。
這告訴圖形硬件開始從第二塊緩存中讀取而不是第一塊。
只要在刷新之前交換，就不會有任何撕裂出現，整個場景都會一下子出現。</p>
<p>這時可以使用以前的幀緩衝了。我們可以將下一幀渲染在它上面了。超棒！</p>
<h2><a href="#模式" name="模式">模式</a></h2>
<p>定義<em>緩衝類</em>封裝了<strong>緩衝</strong>：一段可改變的狀態。
這個緩衝被增量的修改，但我們想要外部的代碼將修改視為單一的原子操作。
為了實現這點，類保存了<em>兩個</em>緩衝的實例：<strong>下一緩衝</strong>和<strong>當前緩衝</strong>。</p>
<p>當信息<em>從</em>緩衝區中讀取，它總是讀取<em>當前的</em>緩衝區。
當信息需要寫<em>到</em>緩存，它總是在<em>下一</em>緩衝區上操作。
當改變完成後，一個<strong>交換</strong>操作會立刻將當前緩衝區和下一緩衝區交換，
這樣新緩衝區就是公共可見的了。舊的緩衝區成為下一個重用的緩衝區。</p>
<h2><a href="#何時使用" name="何時使用">何時使用</a></h2>
<p>這是那種你需要它時自然會想起的模式。
如果你有一個系統需要雙緩衝，它可能有可見的錯誤（撕裂之類的）或者行為不正確。
但是，“當你需要時自然會想起”沒提提供太多有效信息。
更加特殊的，以下情況都滿足時，使用這個模式就很恰當：</p>
<ul>
<li>我們需要維護一些被增量修改的狀態。</li>
<li>在修改到一半的時候，狀態可能會被外部請求。</li>
<li>我們想要防止請求狀態的外部代碼知道內部的工作方式。</li>
<li>我們想要讀取狀態，而且不想等著修改完成。</li>
</ul>
<h2><a href="#記住" name="記住">記住</a></h2>
<p>不像其他較大的架構模式，雙緩衝模式位於底層。
正因如此，它對代碼庫的其他部分影響較小——大多數遊戲甚至不會感到有區別。
儘管這裡還是有幾個警告。</p>
<h3><a href="#交換本身需要時間" name="交換本身需要時間">交換本身需要時間</a></h3>
<p>在狀態被修改後，雙緩衝需要一個<em>swap</em>步驟。
這個操作必須是原子的——在交換時，沒有代碼可以接觸到<em>任何一個</em>狀態。
通常，這就是修改一個指針那麼快，但是如果交換消耗的時間長於修改狀態的時間，那可是毫無助益。</p>
<h3><a href="#我們得保存兩個緩衝區" name="我們得保存兩個緩衝區">我們得保存兩個緩衝區</a></h3>
<p>這個模式的另一個結果是增加了內存的使用。
正如其名，這個模式需要你在內存中一直保留<em>兩個</em>狀態的拷貝。
在內存受限的設備上，你可能要付出慘痛的代價。
如果你不能接受使用兩份內存，你需要使用別的方法保證狀態在修改時不會被請求。</p>
<h2><a href="#示例代碼" name="示例代碼">示例代碼</a></h2>
<p>我們知道了理論，現在看看如何它在實踐中如何應用。
我們編寫了一個非常基礎的圖形系統，允許我們在緩衝幀上描繪像素。
在大多數主機和電腦上，顯卡驅動提供了這種底層的圖形系統，
但是在這裡手動實現有助於理解發生了什麼。首先是緩衝區本身：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Framebuffer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Framebuffer</span><span class="p">()</span> <span class="p">{</span> <span class="n">clear</span><span class="p">();</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">WIDTH</span> <span class="o">*</span> <span class="n">HEIGHT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">pixels_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">WHITE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">pixels_</span><span class="p">[(</span><span class="n">WIDTH</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">getPixels</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">pixels_</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>

  <span class="kt">char</span> <span class="n">pixels_</span><span class="p">[</span><span class="n">WIDTH</span> <span class="o">*</span> <span class="n">HEIGHT</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>它有將整個緩存設置成預設的顏色的操作，也將其一像素設置為特定顏色的操作。
它也有函數<code>getPixels()</code>，讀取保存像素數據的數組。
雖然在這個例子沒有出現，但在實際中，顯卡驅動會頻繁調用這個函數，將緩存中的數據輸送到屏幕上。</p>
<p>我們將整個緩衝區封裝在<code>Scene</code>類中。渲染某物需要做的是在這塊緩衝區上調用一系列<code>draw()</code>。</p>
<p><span name="draw"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Scene</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Framebuffer</span><span class="o">&amp;</span> <span class="n">getBuffer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">buffer_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Framebuffer</span> <span class="n">buffer_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<aside name="draw">
<p>特別的，它畫出來這幅曠世傑作：</p>
<p><img src="images/double-buffer-face.png" width="240" alt="一個像素風的笑臉" /></p>
</aside>
<p>每一幀，遊戲告訴場景去繪製。場景清空緩衝區然後一個接一個繪製一大堆像素。
它也提供了<code>getBuffer()</code>獲得緩衝區，這樣顯卡可以接觸到它。</p>
<p>這看起來直截了當，但是如果就這樣做，我們會遇到麻煩。
顯卡驅動可以在<em>任何</em>時間調用<code>getBuffer()</code>，甚至在這個時候：</p>
<div class="codehilite"><pre><span></span><span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// &lt;- 圖形驅動從這裡讀取像素！</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>


<p>當上面的情況發生時，用戶就會看到臉的眼睛，但是這一幀中嘴卻消失了。
下一幀，又可能在某些別的地方發生衝突。最終結果是糟糕的閃爍圖形。我們會用雙緩衝修復這點：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Scene</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Scene</span><span class="p">()</span>
  <span class="o">:</span> <span class="n">current_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffers_</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
    <span class="n">next_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffers_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>

    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

    <span class="n">swap</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">Framebuffer</span><span class="o">&amp;</span> <span class="n">getBuffer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">current_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">swap</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 只需交換指針</span>
    <span class="n">Framebuffer</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">current_</span><span class="p">;</span>
    <span class="n">current_</span> <span class="o">=</span> <span class="n">next_</span><span class="p">;</span>
    <span class="n">next_</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Framebuffer</span>  <span class="n">buffers_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">Framebuffer</span><span class="o">*</span> <span class="n">current_</span><span class="p">;</span>
  <span class="n">Framebuffer</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>現在<code>Scene</code>有存儲在<code>buffers_</code>數組中的兩個緩衝區，。
我們並不從數組中直接引用它們。而是通過兩個成員，<code>next_</code>和<code>current_</code>，指向這個數組。
當繪製時，我們繪製在<code>next_</code>指向的緩衝區上。
當顯卡驅動需要獲得像素信息時，它總是通過<code>current_</code>獲取<em>另一個</em>緩衝區。</p>
<p>通過這種方式，顯卡驅動永遠看不到我們正在施工的緩衝區。
解決方案的的最後一片碎片就是在場景完成繪製一幀的時候調用<code>swap()</code>。
它通過交換<code>next_</code>和<code>current_</code>的引用完成這一點。
下一次顯卡驅動調用<code>getBuffer()</code>，它會獲得我們剛剛完成渲染的新緩衝區，
然後將剛剛描繪好的緩衝區放在屏幕上。沒有撕裂，也沒有不美觀的問題。</p>
<h3><a href="#不僅是圖形" name="不僅是圖形">不僅是圖形</a></h3>
<p>雙緩衝解決的核心問題是狀態有可能在被修改的同時被請求。
這通常有兩種原因。圖形的例子覆蓋了第一種原因——另一線程的代碼或者另一個中斷的代碼直接訪問了狀態。</p>
<p>但是，還有一個同樣常見的原因：<em>負責修改的</em> 代碼試圖訪問同樣正在修改狀態。
這可能發生在很多地方，特別是實體的物理部分和AI部分，實體在相互交互。
雙緩衝在那裡也十分有用。</p>
<h3><a href="#人工不智能" name="人工不智能">人工不智能</a></h3>
<p>假設我們正在構建一個關於趣味喜劇的遊戲的行為系統。
這個遊戲包括一堆跑來跑去尋歡作樂的角色。這裡是我們的基礎角色：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Actor</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Actor</span><span class="p">()</span> <span class="o">:</span> <span class="n">slapped_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">Actor</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span>      <span class="p">{</span> <span class="n">slapped_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">slap</span><span class="p">()</span>       <span class="p">{</span> <span class="n">slapped_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">wasSlapped</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">slapped_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">slapped_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p><span name="update"></span></p>
<p>每一幀，遊戲要在角色身上調用<code>update()</code>，讓角色做些事情。
特別的，從玩家的角度，<em>所有的角色都看上去應該同時更新</em>。</p>
<aside name="update">
<p>這是<a class="pattern" href="update-method.html">更新方法</a>模式的例子。</p>
</aside>
<p>角色也可以相互交互，這裡的“交互”，我指“可以互相扇對方巴掌”。
當更新時，角色可以在另一個角色身上調用<code>slap()</code>來扇它一巴掌，然後調用<code>wasSlapped()</code>看看自己是不是被扇了。</p>
<p>角色需要一個可以交互的舞台，讓我們來佈置一下：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Stage</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="n">Actor</span><span class="o">*</span> <span class="n">actor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">actors_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">actor</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ACTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">actors_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
      <span class="n">actors_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">NUM_ACTORS</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="n">Actor</span><span class="o">*</span> <span class="n">actors_</span><span class="p">[</span><span class="n">NUM_ACTORS</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p><code>Stage</code>允許我們向其中增加角色，
然後使用簡單的<code>update()</code>調用來更新每個角色。
在用戶看來，角色是同時移動的，但是實際上，它們是依次更新的。</p>
<p>這裡需要注意的另一點是，每個角色的“被扇”狀態在更新後就立刻被清除。
這樣才能保證一個角色對一巴掌只反應一次。</p>
<p>作為一切的開始，讓我們定義一個具體的角色子類。
這裡的喜劇演員很簡單。
他只面向一個角色。當他被扇時——無論是誰扇的他——他的反應是扇他面前的人一巴掌。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Comedian</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Actor</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">face</span><span class="p">(</span><span class="n">Actor</span><span class="o">*</span> <span class="n">actor</span><span class="p">)</span> <span class="p">{</span> <span class="n">facing_</span> <span class="o">=</span> <span class="n">actor</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wasSlapped</span><span class="p">())</span> <span class="n">facing_</span><span class="o">-&gt;</span><span class="n">slap</span><span class="p">();</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Actor</span><span class="o">*</span> <span class="n">facing_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>現在我們把一些喜劇演員丟到舞台上看看發生了什麼。
我們設置三個演員，第一個面朝第二個，第二個面朝第三個，第三個面對第一個，形成一個環：</p>
<div class="codehilite"><pre><span></span><span class="n">Stage</span> <span class="n">stage</span><span class="p">;</span>

<span class="n">Comedian</span><span class="o">*</span> <span class="n">harry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comedian</span><span class="p">();</span>
<span class="n">Comedian</span><span class="o">*</span> <span class="n">baldy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comedian</span><span class="p">();</span>
<span class="n">Comedian</span><span class="o">*</span> <span class="n">chump</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comedian</span><span class="p">();</span>

<span class="n">harry</span><span class="o">-&gt;</span><span class="n">face</span><span class="p">(</span><span class="n">baldy</span><span class="p">);</span>
<span class="n">baldy</span><span class="o">-&gt;</span><span class="n">face</span><span class="p">(</span><span class="n">chump</span><span class="p">);</span>
<span class="n">chump</span><span class="o">-&gt;</span><span class="n">face</span><span class="p">(</span><span class="n">harry</span><span class="p">);</span>

<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">harry</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">baldy</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">chump</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>


<p>最終舞台佈置如下圖。箭頭代表角色的朝向，然後數字代表角色在舞台數組中的索引。</p>
<p><img src="images/double-buffer-slaps-1.png" alt="代表Harry，Baldy和Chump的三個盒子。Harry有一個指向 Baldy的箭頭，Baldy有個指向Chump的箭頭，Chump有個指向Harry的箭頭。" /></p>
<p>我們扇哈利一巴掌，為表演拉開序幕，看看之後會發生什麼：</p>
<div class="codehilite"><pre><span></span><span class="n">harry</span><span class="o">-&gt;</span><span class="n">slap</span><span class="p">();</span>

<span class="n">stage</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>
</pre></div>


<p>記住<code>Stage</code>中的<code>update()</code>函數輪流更新每個角色，
因此如果檢視整個代碼，我們會發現事件這樣發生：</p>
<div class="codehilite"><pre><span></span>Stage updates actor 0 (Harry)
  Harry was slapped, so he slaps Baldy
Stage updates actor 1 (Baldy)
  Baldy was slapped, so he slaps Chump
Stage updates actor 2 (Chump)
  Chump was slapped, so he slaps Harry
Stage update ends
</pre></div>


<p>在單獨的一幀中，初始給哈利的一巴掌傳給了所有的喜劇演員。
現在，讓事物複雜起來，讓我們重新排列舞台數組中角色的排序，
但是繼續保持面向對方的方式。</p>
<p><img src="images/double-buffer-slaps-2.png" alt="還是相同的盒子和箭頭，只是順序變成了Chump, Baldy, Harry." /></p>
<p>我們不動舞台的其餘部分，只是將添加角色到舞台的代碼塊改為如下：</p>
<div class="codehilite"><pre><span></span><span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">harry</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">baldy</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">chump</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>


<p>讓我們看看再次運行時會發生什麼：</p>
<div class="codehilite"><pre><span></span>Stage updates actor 0 (Chump)
  Chump was not slapped, so he does nothing
Stage updates actor 1 (Baldy)
  Baldy was not slapped, so he does nothing
Stage updates actor 2 (Harry)
  Harry was slapped, so he slaps Baldy
Stage update ends
</pre></div>


<p><span name="cascade"></span></p>
<p>哦不。完全不一樣了。問題很明顯。
更新角色時，我們修改了他們的“被扇”狀態，這也是我們在更新時<em>讀取</em>的狀態。
因此，在更新中早先的狀態修改會影響之後<em>同一</em>狀態的修改的步驟。</p>
<aside name="cascade">
<p>如果你繼續更新舞台，你會看到巴掌在角色間逐漸傳遞，每幀傳遞一個。
在第一幀 Harry扇了Baldy。下一幀，Baldy扇了Chump，如此類推。</p>
</aside>
<p>而最終的結果是，一個角色對被扇作出反應可能是在被扇的<em>同一</em>幀或者<em>下一</em>幀，
這完全取決於兩個角色在舞台上是如何排序的。
這沒能滿足我角色同時反應的需求——它們在同一幀中更新的順序不該對結果有影響。</p>
<h3><a href="#緩存巴掌" name="緩存巴掌">緩存巴掌</a></h3>
<p>幸運的是，雙緩衝模式可以幫忙。
這次，不是保存兩大塊“緩衝”，我們緩衝更小粒度的事物：每個角色的“被扇”狀態。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Actor</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Actor</span><span class="p">()</span> <span class="o">:</span> <span class="n">currentSlapped_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">Actor</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">swap</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 交換緩衝區</span>
    <span class="n">currentSlapped_</span> <span class="o">=</span> <span class="n">nextSlapped_</span><span class="p">;</span>

    <span class="c1">// 清空新的“下一個”緩衝區。.</span>
    <span class="n">nextSlapped_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">slap</span><span class="p">()</span>       <span class="p">{</span> <span class="n">nextSlapped_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">wasSlapped</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">currentSlapped_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">currentSlapped_</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">nextSlapped_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>不再使用一個<code>slapped_</code>狀態，每個演員現在使用兩個。
就像我們之前圖形的例子一樣，當前狀態為讀準備，下一狀態為寫準備。</p>
<p><code>reset()</code>函數被替換為<code>swap()</code>。
現在，就在清除交換狀態前，它將下一狀態拷貝到當前狀態上，
使其成為新的當前狀態，這還需要在<code>Stage</code>中進行小小的改變：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Stage</span><span class="o">::</span><span class="n">update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ACTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">actors_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ACTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">actors_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">swap</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><code>update()</code>函數現在更新所有的角色，<em>然後</em> 交換它們的狀態。
最終結果是，角色在實際被扇<em>之後</em>的那幀才能看到巴掌。
這樣一來，角色無論在舞台數組中如何排列，都會保持相同的行為。
無論外部的代碼如何調用，所有的角色在一幀內同時更新。</p>
<h2><a href="#設計決策" name="設計決策">設計決策</a></h2>
<p>雙緩衝很直觀，我們上面看到的例子也覆蓋了大多數你需要的場景。
使用這個模式之前，還有需要做兩個主要的設計決策。</p>
<h3><a href="#緩衝區是如何被交換的？" name="緩衝區是如何被交換的？">緩衝區是如何被交換的？</a></h3>
<p>交換操作是整個過程的最重要的一步，
因為在其發生時，我們必須鎖住兩個緩衝區上的讀取和修改。
為了讓性能最優，我們需要它進行得越快越好。</p>
<ul>
<li>
<p><strong>交換緩衝區的指針或者引用：</strong>
    這是我們圖形例子中的做法，這也是大多數雙緩衝圖形通用的解決方法。</p>
<ul>
<li>
<p><em>速度快。</em> 不管緩衝區有多大，交換都只需賦值一對指針。很難在速度和簡易性上超越它。</p>
</li>
<li>
<p><em>外部代碼不能存儲對緩存的永久指針。</em> 這是主要限制。
由於我們沒有真正地移動<em>數據</em>，本質上做的是周期性地通知代碼庫的其他部分去別處去尋找緩存，
就像前面的舞台類比一樣。這就意味著代碼庫的其他部分不能存儲指向緩衝區中數據的指針——
它一段時間後可能就指向了錯誤的部分。</p>
</li>
</ul>
<p>這會嚴重誤導那些期待緩衝幀永遠在內存中的固定地址的顯卡驅動。在這種情況下，我們不能這麼做。</p>
<ul>
<li>
<p><em>緩衝區中的數據是兩幀之前的數據，而不是上一幀的數據。</em>
接下來的那幀繪製在幀緩衝區上，而不是在它們之間拷貝數據，就像這樣：</p>
<div class="codehilite"><pre><span></span>Frame 1 drawn on buffer A
Frame 2 drawn on buffer B
Frame 3 drawn on buffer A
...
</pre></div>


<p><span name="blur"></span>
你會注意到，當我們繪製第三幀時，緩衝區上的數據是<em>第一幀</em>的，而不是第二幀的。大多數情況下，這不是什麼問題——我們通常在繪製之前清空整個幀。但如果想沿用某些緩存中已有的數據，就需要考慮數據其實比期望的更舊。</p>
<aside name="blur">

<p>舊幀中緩存數據的經典用法是模擬動態模糊。
當前的幀混合一點之前的幀，看起來更像真實的相機捕獲的圖景。</p>
</aside>

</li>
</ul>
</li>
<li>
<p><strong>在緩衝區之間拷貝數據：</strong>
    如果我們不能重定向到其他緩存，唯一的選項就是將下幀的數據實實在在的拷貝到現在這幀上。
    這是我們的扇巴掌喜劇的工作方法。
    這種情況下，使用這種方法因為拷貝狀態——一個簡單的布爾標識——不比修改指向緩存的指針開銷大。</p>
<ul>
<li>
<p><em>下一幀的數據和之前的數據相差一幀。</em>
拷貝數據與在兩塊緩衝區間跳來跳去正相反。
如果我們需要前一幀的數據，這樣我們可以處理更新的數據。</p>
</li>
<li>
<p><em>交換也許更花時間。</em>
這個，當然，是最大的缺點。交換操作現在意味著在內存中拷貝整個緩衝區。
如果緩衝區很大，比如一整個緩衝幀，這需要花費可觀的時間。
由於交換時沒有東西可以讀取或者寫入<em>任何一個</em>緩衝區，這是一個巨大的限制。</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#緩衝的粒度如何？" name="緩衝的粒度如何？">緩衝的粒度如何？</a></h3>
<p>這裡另一問題是緩衝區本身是如何組織的——是單個數據塊還是散佈在對象集合中？
圖形例子是前一種，而角色例子是後一種。</p>
<p>大多數情況下，你緩存的方式自然而然會引導你找到答案，但是這裡也有些靈活度。
比如，角色總能將消息存在獨立的消息塊中，使用索引來引用。</p>
<ul>
<li>
<p><strong>如果緩存是一整塊：</strong></p>
<ul>
<li><em>交換操作更簡單。</em>
由於只有一對緩存，一個簡單的交換就完成了。
如果可以改變指針來交換，那麼不必在意緩衝區大小，只需幾部操作就可以交換整個緩衝區。</p></li>
</ul>
</li>
<li>
<p><strong>如果很多對象都持有一塊數據：</strong></p>
<ul>
<li>
<p><em>交換操作更慢。</em>
為了交換，需要遍歷整個對象集合，通知每個對象交換。</p>
<p>在喜劇的例子中，這沒問題，因為反正需要清除被扇狀態
——每塊緩存的數據每幀都需要接觸。
如果不需要接觸較舊的幀，可以用一個優化在多個對象間分散狀態，獲得使用整塊緩存一樣的性能。</p>
<p>思路是將“當前”和“下一”指針概念，將它們改為對象相關的<em>偏移量</em>。就像這樣：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Actor</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span> <span class="n">current_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">()</span> <span class="p">{</span> <span class="n">current_</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">slap</span><span class="p">()</span>        <span class="p">{</span> <span class="n">slapped_</span><span class="p">[</span><span class="n">next</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">wasSlapped</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">slapped_</span><span class="p">[</span><span class="n">current_</span><span class="p">];</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">current_</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">next</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">current_</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">slapped_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>角色使用<code>current_</code>在狀態數組中查詢，獲得當前的被扇狀態，
下一狀態總是數組中的另一索引，這樣可以用<code>next()</code>來計算。
交換狀態只需改動<code>current_</code>索引。
聰明之處在於<code>swap()</code>現在是<em>靜態</em>函數，它只需被調用一次，<em>每個</em> 角色的狀態都會被交換。</p>
</li>
</ul>
</li>
</ul>
<h2><a href="#參見" name="參見">參見</a></h2>
<ul>
<li>你可以在几乎每個圖形API中找到雙緩衝模式。舉個例子，OpenGL有<code>swapBuffers()</code>，Direct3D有&#8221;swap chains&#8221;, Microsoft的XNA框架有<code>endDraw()</code>方法。</li>
</ul>
<nav>
  <span class="prev">&larr; <a href="sequencing-patterns.html">上一章</a></span>
  <span class="next"><a href="game-loop.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
