<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-Hant-TW" lang="zh-Hant-TW">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="images/favicon-16x16.png" sizes="16x16" />

<title>子類沙箱 &middot; Behavioral Patterns &middot; 遊戲設計模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<!--
delete the font style for english.
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
-->
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="bytecode.html">上一章</a></span>
  <span class="next"><a href="type-object.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
<h1>子類沙箱</h1>
<h1 class="book"><a href="/">遊戲設計模式</a><span class="section"><a href="behavioral-patterns.html">Behavioral Patterns</a></span></h1>
<h2><a href="#意圖" name="意圖">意圖</a></h2>
<p><em>用一系列由基類提供的操作定義子類中的行為。</em></p>
<h2><a href="#動機" name="動機">動機</a></h2>
<p>每個孩子都夢想過變成超級英雄，但是不幸的是，高能射線在地球上很短缺。
遊戲是讓你扮演超級英雄最簡單的方法。
因為我們的遊戲設計者從來沒有學會說“不”，<em>我們的</em> 超級英雄遊戲中有成百上千種不同的超級能力可供選擇。</p>
<p><span name="lots"></span></p>
<p>我們的計劃是創建一個<code>Superpower</code>基類。然後由它派生出各種超級能力的實現類。
我們在程序員隊伍中分發設計文檔，然後開始編程。
當我們完成時，我們就會有上百種超級能力類。</p>
<aside name="lots">
<p>當你發現像這個例子一樣有<em>很多</em>子類時，那通常意味著數據驅動的方式更好。
不再用<em>代碼</em>定義不同的能力，用<em>數據</em>吧。</p>
<p>像<a class="pattern" href="type-object.html">類型對象</a>，<a class="pattern" href="bytecode.html">位元組碼</a>，和<a class="gof-pattern" href="http://en.wikipedia.org/wiki/Interpreter_pattern">解釋器</a>模式都能幫忙。</p>
</aside>
<p>我們想讓玩家處于擁有無限可能的世界中。無論他們在孩童時想象過什麼能力，我們都要在遊戲中展現。
這就意味著這些超能力子類需要做任何事情：
播放聲音，產生視覺刺激，與AI交互，創建和銷毀其他遊戲實體，與物理打交道。沒有哪處代碼是它們不會接觸的。</p>
<p>假設我們讓團隊信馬由繮地寫超能力類。會發生什麼？</p>
<ul>
<li>
<p><em>會有很多冗餘代碼。</em>
當超能力種類繁多，我們可以預期有很多重疊。
很多超能力都會用相同的方式產生視覺效果並播放聲音。
當你坐下來看看，冷凍光線，熱能光線，芥末醬光線都很相似。
如果人們實現這些的時候沒有協同，那就會有很多冗餘的代碼和重複勞動。</p>
</li>
<li>
<p><em>遊戲引擎中的每一部分都會與這些類耦合。</em>
沒有深入瞭解的話，任何人都能寫出直接調用子系統的代碼，但子系統從來沒打算直接與超能力類綁定。
就算渲染系統被好好組織成多個層次，只有一個能被外部的圖形引擎使用，
我們可以打賭，最終超級能力代碼會與每一個接觸。</p>
</li>
<li>
<p><em>當外部代碼需要改變時，一些隨機超能力代碼有很大幾率會損壞。</em>
一旦我們有了不同的超能力類綁定到遊戲引擎的多個部分，改變那些部分必然影響超能力類。
這可不合理，因為圖形，音頻，UI程序員很可能不想<em>也</em>成為玩法程序員。</p>
</li>
<li>
<p><em>很難定義所有超能力遵守的不變數。</em>
假設我們想保證超能力播放的所有音頻都有正確的順序和優先順序。
如果我們幾百個類都直接調用音頻引擎，就沒什麼好辦法來完成這點。</p>
</li>
</ul>
<p>我們要的是給每個實現超能力的玩法程序員一系列可使用的基本單元。
你想要播放聲音？這是你的<code>playSound()</code>函數。
你想要粒子效果？這是你的<code>spawnParticles()</code>函數。
我們保證了這些操作覆蓋了你要做的事情，所以你不需要<code>#include</code>隨機的標頭檔，干擾到代碼庫的其他部分。</p>
<p>我們實現的方法是通過定義這些操作為<code>Superpower</code><em>基類</em>的<em>protected方法</em>。
將它們放在基類給了每個子類直接便捷的途徑獲取方法。
讓它們為protected（很可能不是虛方法）方法暗示了它們存在就是為了被子類<em>調用</em>。</p>
<p>一旦有了這些東西來使用，我們需要一個地方使用他們。
為了做到那點，我們定義<em>沙箱方法</em>，這是子類必須實現的抽象的protected方法。
有了那些，要實現一種新的能力，你需要：</p>
<ol>
<li>創建從<code>Superpower</code>繼承的新類。</li>
<li>重載沙箱方法<code>activate()</code>。</li>
<li>通過調用<code>Superpower</code>提供的protected方法實現主體。</li>
</ol>
<p>我們現在可以使用這些高層次的操作來解決冗餘代碼問題了。
當我們看到代碼在多個子類間重複，我們總可以將其打包到<code>Superpower</code>中，作為它們都可以使用的新操作。</p>
<p>我們通過將耦合約束到一個地方解決了耦合問題。
<code>Superpower</code>最終與不同的系統耦合，但是繼承它的幾百個類不會。
相反，它們<em>只</em>耦合基類。
當遊戲系統的某部分改變時，修改<code>Superpower</code>也許是必須的，但是眾多的子類不需要修改。</p>
<p><span name="wide"></span></p>
<p>這個模式帶來淺層但是廣泛的類層次。
你的繼承鏈不<em>深</em>，但是有<em>很多</em>類與<code>Superpower</code>掛鉤。
通過使用有很多直接子類的基類，我們在代碼庫中創造了一個支撐點。
我們投入到<code>Superpower</code>的時間和愛可以讓遊戲中眾多類獲益。</p>
<aside name="wide">
<p>最近，你發現很多人批評面向對象語言中的繼承。
繼承<em>是</em>有問題——在代碼庫中沒有比父類子類之間的耦合更深的了——但我發現<em>扁平的</em>繼承樹比起<em>深的</em>繼承樹更好處理。</p>
</aside>
<h2><a href="#模式" name="模式">模式</a></h2>
<p><strong>基類</strong>定義抽象的<strong>沙箱方法</strong>和幾個<strong>提供的操作</strong>。
將操作標為protected，表明它們只為子類所使用。
每個推導出的<strong>沙箱子類</strong>用提供的操作實現了沙箱涵數。</p>
<h2><a href="#何時使用" name="何時使用">何時使用</a></h2>
<p>子類沙箱模式是潛伏在代碼庫中簡單常用的模式，哪怕是在遊戲之外的地方亦有應用。
如果你有一個非虛的protected方法，你可能已在用類似的東西了。
沙箱方法在以下情況適用：</p>
<ul>
<li>
<p>你有一個能推導很多子類的基類。</p>
</li>
<li>
<p>基類可以提供子類需要的所有操作。</p>
</li>
<li>
<p>在子類中有行為重複，你想要更容易的在它們間分享代碼。</p>
</li>
<li>
<p>你想要最小化子類和程序的其他部分的耦合。</p>
</li>
</ul>
<h2><a href="#記住" name="記住">記住</a></h2>
<p>“繼承”在很多編程圈子近來為人詬病，原因之一是基類趨向于增加越來越多的代碼
這個模式特別容易染上這個毛病。</p>
<p>由於子類通過基類接觸遊戲的剩餘部分，基類最後和子類需要的<em>每個</em>系統耦合。
當然，子類也緊密的與基類相綁定。這種蛛網耦合讓你很難在不破壞什麼的情況下改變基類——你得到了（脆弱的基類問題）<a href="http://en.wikipedia.org/wiki/Fragile_base_class">brittle base class problem</a>。</p>
<p>硬幣的另一面是由於你耦合的大部分都被推到了基類，子類現在與世界的其他部分分離。
理想的情況下，你大多數的行為都載子類中。這意味著你的代碼庫大部分是孤立的，很容易管理。</p>
<p>如果你發現這個模式正把你的基類變成一鍋代碼糊糊，
考慮將它提供的一些操作放入分離的類中，
這樣基類可以分散它的責任。<a class="pattern" href="component.html">組件</a>模式可以在這裡幫上忙。</p>
<h2><a href="#示例代碼" name="示例代碼">示例代碼</a></h2>
<p>因為這個模式太簡單了，示例代碼中沒有太多東西。
這不是說它沒用——這個模式關鍵在於“意圖”，而不是它實現的複雜度。</p>
<p>我們從<code>Superpower</code>基類開始：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Superpower</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Superpower</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">activate</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">sound</span><span class="p">,</span> <span class="kt">double</span> <span class="n">volume</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">spawnParticles</span><span class="p">(</span><span class="n">ParticleType</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p><code>activate()</code>方法是沙箱方法。由於它是抽象虛函數，子類<em>必須</em>重載它。
這讓那些需要創建子類的人知道要做哪些工作。</p>
<p>其他的protected函數<code>move()</code>，<code>playSound()</code>，和<code>spawnParticles()</code>都是提供的操作。
它們是子類在實現<code>activate()</code>要調用的。</p>
<p>在這個例子中，我們沒有實現提供的操作，但真正的遊戲在那裡有真正的代碼。
那些代碼中，<code>Superpower</code>與遊戲中其他部分的耦合——<code>move()</code>也許調用物理代碼，<code>playSound()</code>會與音頻引擎交互，等等。
由於這都在基類的<em>實現</em>中，保證了耦合封閉在<code>Superpower</code>中。</p>
<p>好了，拿出我們的放射蜘蛛，創建個能力。像這樣：</p>
<p><span name="jump"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SkyLaunch</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Superpower</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">activate</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 空中滑行</span>
    <span class="n">playSound</span><span class="p">(</span><span class="n">SOUND_SPROING</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
    <span class="n">spawnParticles</span><span class="p">(</span><span class="n">PARTICLE_DUST</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">move</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<aside name="jump">
<p>好吧，也許<em>跳躍</em>不是<em>超級能力</em>，但我在這裡講的是基礎知識。</p>
</aside>
<p>這種能力將超級英雄射向天空，播放合適的聲音，揚起塵土。
如果所有的超能力都這樣簡單——只是聲音，粒子效果，動作的組合——那麼就根本不需要這個模式了。
相反，<code>Superpower</code>有內置的<code>activate()</code>能獲取聲音ID，粒子類型和運動的欄位。
但是這只在所有能力運行方式相同，只在數據上不同時才可行。讓我們精細一些：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Superpower</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">getHeroX</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="kt">double</span> <span class="n">getHeroY</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="kt">double</span> <span class="n">getHeroZ</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="c1">// 退出之類的……</span>
<span class="p">};</span>
</pre></div>


<p>這裡我們增加了些方法獲取英雄的位置。我們的<code>SkyLaunch</code>現在可以使用它們了：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SkyLaunch</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Superpower</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">activate</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getHeroZ</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// 在地面上，衝向空中</span>
      <span class="n">playSound</span><span class="p">(</span><span class="n">SOUND_SPROING</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
      <span class="n">spawnParticles</span><span class="p">(</span><span class="n">PARTICLE_DUST</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
      <span class="n">move</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">getHeroZ</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">10.0f</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// 接近地面，再跳一次</span>
      <span class="n">playSound</span><span class="p">(</span><span class="n">SOUND_SWOOP</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
      <span class="n">move</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">getHeroZ</span><span class="p">()</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="c1">// 正在空中，跳劈攻擊</span>
      <span class="n">playSound</span><span class="p">(</span><span class="n">SOUND_DIVE</span><span class="p">,</span> <span class="mf">0.7f</span><span class="p">);</span>
      <span class="n">spawnParticles</span><span class="p">(</span><span class="n">PARTICLE_SPARKLES</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">move</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">getHeroZ</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p><span name="data"></span>
由於我們現在可以訪問狀態，沙箱方法可以做有用有趣的控制流了。
這還需要幾個簡單的<code>if</code>聲明，
但你可以做任何你想做東西。
使用包含任意代碼的成熟沙箱方法，天高任鳥飛了。</p>
<aside name="data">
<p>早先，我建議以數據驅動的方式建立超能力。
這裡是你可能<em>不</em>想那麼做的原因之一。
如果你的行為複雜而使用命令式風格，它更難在數據中定義。</p>
</aside>
<h2><a href="#設計決策" name="設計決策">設計決策</a></h2>
<p>如你所見，子類沙箱是一個“軟”模式。它表述了一個基本思路，但是沒有很多細節機制。
這意味著每次使用都面臨著一些有趣的選擇。這裡是一些需要思考的問題。</p>
<h3><a href="#應該提供什麼操作？" name="應該提供什麼操作？">應該提供什麼操作？</a></h3>
<p>這是最大的問題。這深深影響了模式感覺上和實際上有多好。
在一種極端中，基類几乎不提供<em>任何</em>操作。只有一個沙箱方法。
為了實現功能，總是需要調用基類外部的系統。如果你這樣做，很難說你在使用這個模式。</p>
<p><span name="include"></span></p>
<p>另一個極端，基類提供了<em>所有</em>子類也許需要的操作。
子類<em>只</em>與基類耦合，不調用任何外部系統的東西。</p>
<aside name="include">
<p>具體來說，這意味著每個子類的源檔案只需要<code>#include</code>它的基類標頭檔。</p>
</aside>
<p>在這兩極端之間，操作由基類提供還是向外部直接調用有很大的操作餘地。
你提供的操作越多，外部系統與子類耦合越少，但是與基類耦合<em>越多</em>。
從子類中移除了耦合是通過將耦合推給基類完成的。</p>
<p>如果你有一堆與外部系統耦合的子類的話，這很好。
通過將耦合移到提供的操作中，你將其移動到了一個地方：基類。但是你越這麼做，基類就越大越難管理。</p>
<p>所以分界線在哪裡？這裡是一些首要原則：</p>
<ul>
<li>
<p>如果提供的操作只被一個或幾個子類使用，將操作加入基類獲益不會太多。
你向基類添加了會影響所有事物的複雜性，但是只有少數幾個類受益。</p>
<p>讓該操作與其他提供的操作保持一致或許有價值，但讓使用操作的子類直接調用外部系統也許更簡單明了。</p>
</li>
</ul>
<p><span name="safe"></span></p>
<ul>
<li>
<p>當你調用遊戲中其他地方的方法，如果方法沒有修改狀態就有更少的干擾。
它仍然製造耦合，但是這是“安全的”耦合，因為它沒有破壞遊戲中的任何東西。</p>
<aside name="safe">

<p>“安全的”在這裡打了引號是因為嚴格來說，接觸數據也能造成問題。
如果你的遊戲是多線程的，讀取的數據可能正在被修改。如果你不小心，就會讀入錯誤的數據。</p>
<p>另一個不愉快的情況是，如果你的遊戲狀態是嚴格確定性的（很多在線遊戲為了保持玩家同步都是這樣的）。
接觸了遊戲同步狀態之外的東西會造成極糟的不確定性漏洞。</p>
</aside>

<p>另一方面，修改狀態的調用會和代碼庫的其他方面緊密綁定，你需要三思。打包他們成基類提供的操作是個好的候選項。</p>
</li>
<li>
<p>如果操作只是增加了向外部系統的轉發調用，那它就沒增加太多價值。那種情況下，也許直接調用外部系統的方法更簡單。</p>
<p>但是，簡單的轉發也是有用的——那些方法接觸了基類不想直接暴露給子類的狀態。
舉個例子，假設<code>Superpower</code>提供這個：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">sound</span><span class="p">,</span> <span class="kt">double</span> <span class="n">volume</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">soundEngine_</span><span class="p">.</span><span class="n">play</span><span class="p">(</span><span class="n">sound</span><span class="p">,</span> <span class="n">volume</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>它只是轉發調用給<code>Superpower</code>中<code>soundEngine_</code>欄位。
但是，好處是將欄位封裝在<code>Superpower</code>中，避免子類接觸。</p>
</li>
</ul>
<h3><a href="#方法應該直接提供，還是包在對象中提供？" name="方法應該直接提供，還是包在對象中提供？">方法應該直接提供，還是包在對象中提供？</a></h3>
<p>這個模式的挑戰是基類中最終加入了很多方法。
你可以將一些方法移到其他類中來緩和。基類通過返回對象提供方法。</p>
<p>舉個例子，為了讓超能力播放聲音，我們可以直接將它們加到<code>Superpower</code>中：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Superpower</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">sound</span><span class="p">,</span> <span class="kt">double</span> <span class="n">volume</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">stopSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">sound</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">setVolume</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">sound</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="c1">// 沙盒方法和其他操作……</span>
<span class="p">};</span>
</pre></div>


<p>但是如果<code>Superpower</code>已經很龐雜了，我們也許想要避免這樣。
取而代之的是創建<code>SoundPlayer</code>類暴露該函數：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SoundPlayer</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="n">playSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">sound</span><span class="p">,</span> <span class="kt">double</span> <span class="n">volume</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">stopSound</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">sound</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">setVolume</span><span class="p">(</span><span class="n">SoundId</span> <span class="n">sound</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 實現代碼……</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p><code>Superpower</code>提供了對其的接觸：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Superpower</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">SoundPlayer</span><span class="o">&amp;</span> <span class="n">getSoundPlayer</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">soundPlayer_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 沙箱方法和其他操作……</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">SoundPlayer</span> <span class="n">soundPlayer_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>將提供的操作分流到輔助類可以為你做一些事情：</p>
<ul>
<li>
<p><em>減少了基類中的方法。</em>
在這裡的例子中，將三個方法變成了一個簡單的獲取函數。</p>
</li>
<li>
<p><em>在輔助類中的代碼通常更好管理。</em>
像<code>Superpower</code>的核心基類，不管意圖如何好，它被太多的類依賴而很難改變。
通過將函數移到耦合較少的次要類，代碼變得更容易被使用而不破壞任何東西。</p>
</li>
<li>
<p><em>減少了基類和其他系統的耦合度。</em>
當<code>playSound()</code>方法直接在<code>Superpower</code>時，基類與<code>SoundId</code>以及其他涉及音頻代碼直接綁定。
將它移動到<code>SoundPlayer</code>中，減少了<code>Superpower</code>與<code>SoundPlayer</code>類的耦合，這就封裝了它其他的依賴。</p>
</li>
</ul>
<h3><a href="#基類如何獲得它需要的狀態？" name="基類如何獲得它需要的狀態？">基類如何獲得它需要的狀態？</a></h3>
<p>你的基類經常需要將對子類隱藏的數據封裝起來。
在第一個例子中，<code>Superpower</code>類提過了<code>spawnParticles()</code>方法。
如果方法的實現需要一些粒子系統對象，怎麼獲得呢？</p>
<ul>
<li>
<p><strong>將它傳給基類構造器：</strong></p>
<p>最簡單的解決方案是讓基類將其作為構造器變數：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Superpower</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Superpower</span><span class="p">(</span><span class="n">ParticleSystem</span><span class="o">*</span> <span class="n">particles</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">particles_</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="c1">// 沙箱方法和其他操作……</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">ParticleSystem</span><span class="o">*</span> <span class="n">particles_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>這安全地保證了每個超能力在構造時能得到粒子系統。但讓我們看看子類：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SkyLaunch</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Superpower</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">SkyLaunch</span><span class="p">(</span><span class="n">ParticleSystem</span><span class="o">*</span> <span class="n">particles</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Superpower</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
  <span class="p">{}</span>
<span class="p">};</span>
</pre></div>


<p>我們在這看到了問題。每個子類都需要構造器調用基類構造器並傳遞變數。這讓子類接觸了我們不想要它知道的狀態。</p>
<p>這也讓造成了維護的負擔。如果我們後續向基類添加了狀態，每個子類都需要修改並傳遞這個狀態。</p>
</li>
<li>
<p><strong>使用兩階初始化：</strong></p>
<p>為了避免通過構造器傳遞所有東西，我們可以將初始化劃分為兩個部分。
構造器不接受任何參數，只是創建對象。然後，我們調用定義在基類的分離方法傳入必要的數據：</p>
<div class="codehilite"><pre><span></span><span class="n">Superpower</span><span class="o">*</span> <span class="n">power</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SkyLaunch</span><span class="p">();</span>
<span class="n">power</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">particles</span><span class="p">);</span>
</pre></div>


<p>注意我們沒有為<code>SkyLaunch</code>的構造器傳入任何東西，它與<code>Superpower</code>中想要保持私有的任何東西都不耦合。
這種方法的問題在於，你要保證永遠記得調用<code>init()</code>，如果忘了，你會獲得處于半完成的，無法運行的超能力。</p>
<p>你可以將整個過程封裝到一個函數中來修復這一點，就像這樣：</p>
<p><span name="friend"></span></p>
<div class="codehilite"><pre><span></span><span class="n">Superpower</span><span class="o">*</span> <span class="nf">createSkyLaunch</span><span class="p">(</span><span class="n">ParticleSystem</span><span class="o">*</span> <span class="n">particles</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Superpower</span><span class="o">*</span> <span class="n">power</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SkyLaunch</span><span class="p">();</span>
  <span class="n">power</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">particles</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">power</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<aside name="friend">

<p>使用一點像私有構造器和友類的技巧，你可以保證<code>createSkylaunch()</code>函數是唯一能夠創建能力的函數。
這樣，你不會忘記任何初始化步驟。</p>
</aside>

</li>
<li>
<p><strong>讓狀態靜態化：</strong></p>
<p>在先前的例子中，我們用粒子系統初始化每一個<code>Superpower</code><em>實例</em>。
在每個能力都需要自己獨特的狀態時這是有意義的。但是如果粒子系統是<a class="pattern" href="singleton.html">單例</a>，那麼每個能力都會分享相同的狀態。</p>
<p>如果是這樣，我們可以讓狀態是基類私有而<span name="singleton"><em>靜態</em></span>的。
遊戲仍然要保證初始化狀態，但是它只需要為整個遊戲初始化<code>Superpower</code><em>類</em>一遍，而不是為每個實例初始化一遍。</p>
<aside name="singleton">

<p>記住單例仍然有很多問題。你在很多對象中分享了狀態（所有的<code>Superpower</code>實例）。
粒子系統被封裝了，因此它不是全局<em>可見的</em>，這很好，但它們都訪問同一對象，這讓分析起來更加困難了。</p>
</aside>

<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Superpower</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="n">ParticleSystem</span><span class="o">*</span> <span class="n">particles</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">particles_</span> <span class="o">=</span> <span class="n">particles</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 沙箱方法和其他操作……</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">ParticleSystem</span><span class="o">*</span> <span class="n">particles_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>注意這裡的<code>init()</code>和<code>particles_</code>都是靜態的。
只要遊戲早先調用過一次<code>Superpower::init()</code>，每種能力都能接觸粒子系統。
同時，可以調用正確的推導類構造器來自由創建<code>Superpower</code>實例。</p>
<p>更棒的是，現在<code>particles_</code>是<em>靜態</em>變數，
我們不需要在每個<code>Superpower</code>中存儲它，這樣我們的類佔據的內存更少了。</p>
</li>
<li>
<p><strong>使用服務定位器：</strong></p>
<p>前一選項中，外部代碼要在基類請求前壓入基類需要的全部狀態。
初始化的責任交給了周圍的代碼。另一選項是讓基類拉取它需要的狀態。
而做到這點的一種實現的方法是使用<a class="pattern" href="service-locator.html">服務定位器</a>模式：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Superpower</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">spawnParticles</span><span class="p">(</span><span class="n">ParticleType</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ParticleSystem</span><span class="o">&amp;</span> <span class="n">particles</span> <span class="o">=</span> <span class="n">Locator</span><span class="o">::</span><span class="n">getParticles</span><span class="p">();</span>
    <span class="n">particles</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 沙箱方法和其他操作……</span>
<span class="p">};</span>
</pre></div>


<p>這兒，<code>spawnParticles()</code>需要粒子系統，不是外部系統<em>給</em>它，而是它自己從服務定位器中拿了一個。</p>
</li>
</ul>
<h2><a href="#參見" name="參見">參見</a></h2>
<ul>
<li>
<p>當你使用<a class="pattern" href="update-method.html">更新模式</a>時，你的更新函數通常也是沙箱方法。</p>
</li>
<li>
<p>這個模式與<a class="gof-pattern" href="http://en.wikipedia.org/wiki/Template_method_pattern">模板方法</a>正相反。
兩種模式中，都使用一系列受限操作實現方法。
使用子類沙箱時，方法在推導類中，受限操作在基類中。
使用模板方法時，<em>基類</em> 有方法，而受限操作在<em>推導</em>類中。</p>
</li>
<li>
<p>你也可以認為這個模式是<a class="gof-pattern" href="http://en.wikipedia.org/wiki/Facade_Pattern">外觀</a>模式的變形。
外觀模式將一系列不同系統藏在簡化的API後。使用子類沙箱，基類起到了在子類前隱藏整個遊戲引擎的作用。</p>
</li>
</ul>
<nav>
  <span class="prev">&larr; <a href="bytecode.html">上一章</a></span>
  <span class="next"><a href="type-object.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">首頁</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
